<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>gmock-matchers.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// Copyright 2007, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


// Google Mock - a framework for writing C++ mock classes.
//
// The MATCHER* family of macros can be used in a namespace scope to
// define custom matchers easily.
//
// Basic Usage
// ===========
//
// The syntax
//
//   MATCHER(name, description_string) { statements; }
//
// defines a matcher with the given name that executes the statements,
// which must return a bool to indicate if the match succeeds.  Inside
// the statements, you can refer to the value being matched by 'arg',
// and refer to its type by 'arg_type'.
//
// The description string documents what the matcher does, and is used
// to generate the failure message when the match fails.  Since a
// MATCHER() is usually defined in a header file shared by multiple
// C++ source files, we require the description to be a C-string
// literal to avoid possible side effects.  It can be empty, in which
// case we'll use the sequence of words in the matcher name as the
// description.
//
// For example:
//
//   MATCHER(IsEven, "") { return (arg % 2) == 0; }
//
// allows you to write
//
//   // Expects mock_foo.Bar(n) to be called where n is even.
//   EXPECT_CALL(mock_foo, Bar(IsEven()));
//
// or,
//
//   // Verifies that the value of some_expression is even.
//   EXPECT_THAT(some_expression, IsEven());
//
// If the above assertion fails, it will print something like:
//
//   Value of: some_expression
//   Expected: is even
//     Actual: 7
//
// where the description "is even" is automatically calculated from the
// matcher name IsEven.
//
// Argument Type
// =============
//
// Note that the type of the value being matched (arg_type) is
// determined by the context in which you use the matcher and is
// supplied to you by the compiler, so you don't need to worry about
// declaring it (nor can you).  This allows the matcher to be
// polymorphic.  For example, IsEven() can be used to match any type
// where the value of "(arg % 2) == 0" can be implicitly converted to
// a bool.  In the "Bar(IsEven())" example above, if method Bar()
// takes an int, 'arg_type' will be int; if it takes an unsigned long,
// 'arg_type' will be unsigned long; and so on.
//
// Parameterizing Matchers
// =======================
//
// Sometimes you'll want to parameterize the matcher.  For that you
// can use another macro:
//
//   MATCHER_P(name, param_name, description_string) { statements; }
//
// For example:
//
//   MATCHER_P(HasAbsoluteValue, value, "") { return abs(arg) == value; }
//
// will allow you to write:
//
//   EXPECT_THAT(Blah("a"), HasAbsoluteValue(n));
//
// which may lead to this message (assuming n is 10):
//
//   Value of: Blah("a")
//   Expected: has absolute value 10
//     Actual: -9
//
// Note that both the matcher description and its parameter are
// printed, making the message human-friendly.
//
// In the matcher definition body, you can write 'foo_type' to
// reference the type of a parameter named 'foo'.  For example, in the
// body of MATCHER_P(HasAbsoluteValue, value) above, you can write
// 'value_type' to refer to the type of 'value'.
//
// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P$n to
// support multi-parameter matchers.
//
// Describing Parameterized Matchers
// =================================
//
// The last argument to MATCHER*() is a string-typed expression.  The
// expression can reference all of the matcher's parameters and a
// special bool-typed variable named 'negation'.  When 'negation' is
// false, the expression should evaluate to the matcher's description;
// otherwise it should evaluate to the description of the negation of
// the matcher.  For example,
//
//   using testing::PrintToString;
//
//   MATCHER_P2(InClosedRange, low, hi,
//       std::string(negation ? "is not" : "is") + " in range [" +
//       PrintToString(low) + ", " + PrintToString(hi) + "]") {
//     return low &lt;= arg &amp;&amp; arg &lt;= hi;
//   }
//   ...
//   EXPECT_THAT(3, InClosedRange(4, 6));
//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));
//
// would generate two failures that contain the text:
//
//   Expected: is in range [4, 6]
//   ...
//   Expected: is not in range [2, 4]
//
// If you specify "" as the description, the failure message will
// contain the sequence of words in the matcher name followed by the
// parameter values printed as a tuple.  For example,
//
//   MATCHER_P2(InClosedRange, low, hi, "") { ... }
//   ...
//   EXPECT_THAT(3, InClosedRange(4, 6));
//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));
//
// would generate two failures that contain the text:
//
//   Expected: in closed range (4, 6)
//   ...
//   Expected: not (in closed range (2, 4))
//
// Types of Matcher Parameters
// ===========================
//
// For the purpose of typing, you can view
//
//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }
//
// as shorthand for
//
//   template &lt;typename p1_type, ..., typename pk_type&gt;
//   FooMatcherPk&lt;p1_type, ..., pk_type&gt;
//   Foo(p1_type p1, ..., pk_type pk) { ... }
//
// When you write Foo(v1, ..., vk), the compiler infers the types of
// the parameters v1, ..., and vk for you.  If you are not happy with
// the result of the type inference, you can specify the types by
// explicitly instantiating the template, as in Foo&lt;long, bool&gt;(5,
// false).  As said earlier, you don't get to (or need to) specify
// 'arg_type' as that's determined by the context in which the matcher
// is used.  You can assign the result of expression Foo(p1, ..., pk)
// to a variable of type FooMatcherPk&lt;p1_type, ..., pk_type&gt;.  This
// can be useful when composing matchers.
//
// While you can instantiate a matcher template with reference types,
// passing the parameters by pointer usually makes your code more
// readable.  If, however, you still want to pass a parameter by
// reference, be aware that in the failure message generated by the
// matcher you will see the value of the referenced object but not its
// address.
//
// Explaining Match Results
// ========================
//
// Sometimes the matcher description alone isn't enough to explain why
// the match has failed or succeeded.  For example, when expecting a
// long string, it can be very helpful to also print the diff between
// the expected string and the actual one.  To achieve that, you can
// optionally stream additional information to a special variable
// named result_listener, whose type is a pointer to class
// MatchResultListener:
//
//   MATCHER_P(EqualsLongString, str, "") {
//     if (arg == str) return true;
//
//     *result_listener &lt;&lt; "the difference: "
///                     &lt;&lt; DiffStrings(str, arg);
//     return false;
//   }
//
// Overloading Matchers
// ====================
//
// You can overload matchers with different numbers of parameters:
//
//   MATCHER_P(Blah, a, description_string1) { ... }
//   MATCHER_P2(Blah, a, b, description_string2) { ... }
//
// Caveats
// =======
//
// When defining a new matcher, you should also consider implementing
// MatcherInterface or using MakePolymorphicMatcher().  These
// approaches require more work than the MATCHER* macros, but also
// give you more control on the types of the value being matched and
// the matcher parameters, which may leads to better compiler error
// messages when the matcher is used wrong.  They also allow
// overloading matchers based on parameter types (as opposed to just
// based on the number of parameters).
//
// MATCHER*() can only be used in a namespace scope as templates cannot be
// declared inside of a local class.
//
// More Information
// ================
//
// To learn more about using these macros, please search for 'MATCHER'
// on
// https://github.com/google/googletest/blob/master/docs/gmock_cook_book.md
//
// This file also implements some commonly used argument matchers.  More
// matchers can be defined by the user implementing the
// MatcherInterface&lt;T&gt; interface if necessary.
//
// See googletest/include/gtest/gtest-matchers.h for the definition of class
// Matcher, class MatcherInterface, and others.

// GOOGLETEST_CM0002 DO NOT DELETE

#ifndef GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
#define GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_

#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;initializer_list&gt;
#include &lt;iterator&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;ostream&gt;  // NOLINT
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "gmock/internal/gmock-internal-utils.h"
#include "gmock/internal/gmock-port.h"
#include "gmock/internal/gmock-pp.h"
#include "gtest/gtest.h"

// MSVC warning C5046 is new as of VS2017 version 15.8.
#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1915
#define GMOCK_MAYBE_5046_ 5046
#else
#define GMOCK_MAYBE_5046_
#endif

GTEST_DISABLE_MSC_WARNINGS_PUSH_(
    4251 GMOCK_MAYBE_5046_ /* class A needs to have dll-interface to be used by
                              clients of class B */
    /* Symbol involving type with internal linkage not defined */)

namespace testing {

// To implement a matcher Foo for type T, define:
//   1. a class FooMatcherImpl that implements the
//      MatcherInterface&lt;T&gt; interface, and
//   2. a factory function that creates a Matcher&lt;T&gt; object from a
//      FooMatcherImpl*.
//
// The two-level delegation design makes it possible to allow a user
// to write "v" instead of "Eq(v)" where a Matcher is expected, which
// is impossible if we pass matchers by pointers.  It also eases
// ownership management as Matcher objects can now be copied like
// plain values.

// A match result listener that stores the explanation in a string.
class StringMatchResultListener : public MatchResultListener {
 public:
  StringMatchResultListener() : MatchResultListener(&amp;ss_) {}

  // Returns the explanation accumulated so far.
  std::string str() const { return ss_.str(); }

  // Clears the explanation accumulated so far.
  void Clear() { ss_.str(""); }

 private:
  ::std::stringstream ss_;

  GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);
};

// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION
// and MUST NOT BE USED IN USER CODE!!!
namespace internal {

// The MatcherCastImpl class template is a helper for implementing
// MatcherCast().  We need this helper in order to partially
// specialize the implementation of MatcherCast() (C++ allows
// class/struct templates to be partially specialized, but not
// function templates.).

// This general version is used when MatcherCast()'s argument is a
// polymorphic matcher (i.e. something that can be converted to a
// Matcher but is not one yet; for example, Eq(value)) or a value (for
// example, "hello").
template &lt;typename T, typename M&gt;
class MatcherCastImpl {
 public:
  static Matcher&lt;T&gt; Cast(const M&amp; polymorphic_matcher_or_value) {
    // M can be a polymorphic matcher, in which case we want to use
    // its conversion operator to create Matcher&lt;T&gt;.  Or it can be a value
    // that should be passed to the Matcher&lt;T&gt;'s constructor.
    //
    // We can't call Matcher&lt;T&gt;(polymorphic_matcher_or_value) when M is a
    // polymorphic matcher because it'll be ambiguous if T has an implicit
    // constructor from M (this usually happens when T has an implicit
    // constructor from any type).
    //
    // It won't work to unconditionally implicit_cast
    // polymorphic_matcher_or_value to Matcher&lt;T&gt; because it won't trigger
    // a user-defined conversion from M to T if one exists (assuming M is
    // a value).
    return CastImpl(polymorphic_matcher_or_value,
                    std::is_convertible&lt;M, Matcher&lt;T&gt;&gt;{},
                    std::is_convertible&lt;M, T&gt;{});
  }

 private:
  template &lt;bool Ignore&gt;
  static Matcher&lt;T&gt; CastImpl(const M&amp; polymorphic_matcher_or_value,
                             std::true_type /* convertible_to_matcher */,
                             std::integral_constant&lt;bool, Ignore&gt;) {
    // M is implicitly convertible to Matcher&lt;T&gt;, which means that either
    // M is a polymorphic matcher or Matcher&lt;T&gt; has an implicit constructor
    // from M.  In both cases using the implicit conversion will produce a
    // matcher.
    //
    // Even if T has an implicit constructor from M, it won't be called because
    // creating Matcher&lt;T&gt; would require a chain of two user-defined conversions
    // (first to create T from M and then to create Matcher&lt;T&gt; from T).
    return polymorphic_matcher_or_value;
  }

  // M can't be implicitly converted to Matcher&lt;T&gt;, so M isn't a polymorphic
  // matcher. It's a value of a type implicitly convertible to T. Use direct
  // initialization to create a matcher.
  static Matcher&lt;T&gt; CastImpl(const M&amp; value,
                             std::false_type /* convertible_to_matcher */,
                             std::true_type /* convertible_to_T */) {
    return Matcher&lt;T&gt;(ImplicitCast_&lt;T&gt;(value));
  }

  // M can't be implicitly converted to either Matcher&lt;T&gt; or T. Attempt to use
  // polymorphic matcher Eq(value) in this case.
  //
  // Note that we first attempt to perform an implicit cast on the value and
  // only fall back to the polymorphic Eq() matcher afterwards because the
  // latter calls bool operator==(const Lhs&amp; lhs, const Rhs&amp; rhs) in the end
  // which might be undefined even when Rhs is implicitly convertible to Lhs
  // (e.g. std::pair&lt;const int, int&gt; vs. std::pair&lt;int, int&gt;).
  //
  // We don't define this method inline as we need the declaration of Eq().
  static Matcher&lt;T&gt; CastImpl(const M&amp; value,
                             std::false_type /* convertible_to_matcher */,
                             std::false_type /* convertible_to_T */);
};

// This more specialized version is used when MatcherCast()'s argument
// is already a Matcher.  This only compiles when type T can be
// statically converted to type U.
template &lt;typename T, typename U&gt;
class MatcherCastImpl&lt;T, Matcher&lt;U&gt; &gt; {
 public:
  static Matcher&lt;T&gt; Cast(const Matcher&lt;U&gt;&amp; source_matcher) {
    return Matcher&lt;T&gt;(new Impl(source_matcher));
  }

 private:
  class Impl : public MatcherInterface&lt;T&gt; {
   public:
    explicit Impl(const Matcher&lt;U&gt;&amp; source_matcher)
        : source_matcher_(source_matcher) {}

    // We delegate the matching logic to the source matcher.
    bool MatchAndExplain(T x, MatchResultListener* listener) const override {
      using FromType = typename std::remove_cv&lt;typename std::remove_pointer&lt;
          typename std::remove_reference&lt;T&gt;::type&gt;::type&gt;::type;
      using ToType = typename std::remove_cv&lt;typename std::remove_pointer&lt;
          typename std::remove_reference&lt;U&gt;::type&gt;::type&gt;::type;
      // Do not allow implicitly converting base*/&amp; to derived*/&amp;.
      static_assert(
          // Do not trigger if only one of them is a pointer. That implies a
          // regular conversion and not a down_cast.
          (std::is_pointer&lt;typename std::remove_reference&lt;T&gt;::type&gt;::value !=
           std::is_pointer&lt;typename std::remove_reference&lt;U&gt;::type&gt;::value) ||
              std::is_same&lt;FromType, ToType&gt;::value ||
              !std::is_base_of&lt;FromType, ToType&gt;::value,
          "Can't implicitly convert from &lt;base&gt; to &lt;derived&gt;");

      // Do the cast to `U` explicitly if necessary.
      // Otherwise, let implicit conversions do the trick.
      using CastType =
          typename std::conditional&lt;std::is_convertible&lt;T&amp;, const U&amp;&gt;::value,
                                    T&amp;, U&gt;::type;

      return source_matcher_.MatchAndExplain(static_cast&lt;CastType&gt;(x),
                                             listener);
    }

    void DescribeTo(::std::ostream* os) const override {
      source_matcher_.DescribeTo(os);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      source_matcher_.DescribeNegationTo(os);
    }

   private:
    const Matcher&lt;U&gt; source_matcher_;
  };
};

// This even more specialized version is used for efficiently casting
// a matcher to its own type.
template &lt;typename T&gt;
class MatcherCastImpl&lt;T, Matcher&lt;T&gt; &gt; {
 public:
  static Matcher&lt;T&gt; Cast(const Matcher&lt;T&gt;&amp; matcher) { return matcher; }
};

// Template specialization for parameterless Matcher.
template &lt;typename Derived&gt;
class MatcherBaseImpl {
 public:
  MatcherBaseImpl() = default;

  template &lt;typename T&gt;
  operator ::testing::Matcher&lt;T&gt;() const {  // NOLINT(runtime/explicit)
    return ::testing::Matcher&lt;T&gt;(new
                                 typename Derived::template gmock_Impl&lt;T&gt;());
  }
};

// Template specialization for Matcher with parameters.
template &lt;template &lt;typename...&gt; class Derived, typename... Ts&gt;
class MatcherBaseImpl&lt;Derived&lt;Ts...&gt;&gt; {
 public:
  // Mark the constructor explicit for single argument T to avoid implicit
  // conversions.
  template &lt;typename E = std::enable_if&lt;sizeof...(Ts) == 1&gt;,
            typename E::type* = nullptr&gt;
  explicit MatcherBaseImpl(Ts... params)
      : params_(std::forward&lt;Ts&gt;(params)...) {}
  template &lt;typename E = std::enable_if&lt;sizeof...(Ts) != 1&gt;,
            typename = typename E::type&gt;
  MatcherBaseImpl(Ts... params)  // NOLINT
      : params_(std::forward&lt;Ts&gt;(params)...) {}

  template &lt;typename F&gt;
  operator ::testing::Matcher&lt;F&gt;() const {  // NOLINT(runtime/explicit)
    return Apply&lt;F&gt;(MakeIndexSequence&lt;sizeof...(Ts)&gt;{});
  }

 private:
  template &lt;typename F, std::size_t... tuple_ids&gt;
  ::testing::Matcher&lt;F&gt; Apply(IndexSequence&lt;tuple_ids...&gt;) const {
    return ::testing::Matcher&lt;F&gt;(
        new typename Derived&lt;Ts...&gt;::template gmock_Impl&lt;F&gt;(
            std::get&lt;tuple_ids&gt;(params_)...));
  }

  const std::tuple&lt;Ts...&gt; params_;
};

}  // namespace internal

// In order to be safe and clear, casting between different matcher
// types is done explicitly via MatcherCast&lt;T&gt;(m), which takes a
// matcher m and returns a Matcher&lt;T&gt;.  It compiles only when T can be
// statically converted to the argument type of m.
template &lt;typename T, typename M&gt;
inline Matcher&lt;T&gt; MatcherCast(const M&amp; matcher) {
  return internal::MatcherCastImpl&lt;T, M&gt;::Cast(matcher);
}

// This overload handles polymorphic matchers and values only since
// monomorphic matchers are handled by the next one.
template &lt;typename T, typename M&gt;
inline Matcher&lt;T&gt; SafeMatcherCast(const M&amp; polymorphic_matcher_or_value) {
  return MatcherCast&lt;T&gt;(polymorphic_matcher_or_value);
}

// This overload handles monomorphic matchers.
//
// In general, if type T can be implicitly converted to type U, we can
// safely convert a Matcher&lt;U&gt; to a Matcher&lt;T&gt; (i.e. Matcher is
// contravariant): just keep a copy of the original Matcher&lt;U&gt;, convert the
// argument from type T to U, and then pass it to the underlying Matcher&lt;U&gt;.
// The only exception is when U is a reference and T is not, as the
// underlying Matcher&lt;U&gt; may be interested in the argument's address, which
// is not preserved in the conversion from T to U.
template &lt;typename T, typename U&gt;
inline Matcher&lt;T&gt; SafeMatcherCast(const Matcher&lt;U&gt;&amp; matcher) {
  // Enforce that T can be implicitly converted to U.
  static_assert(std::is_convertible&lt;const T&amp;, const U&amp;&gt;::value,
                "T must be implicitly convertible to U");
  // Enforce that we are not converting a non-reference type T to a reference
  // type U.
  GTEST_COMPILE_ASSERT_(
      std::is_reference&lt;T&gt;::value || !std::is_reference&lt;U&gt;::value,
      cannot_convert_non_reference_arg_to_reference);
  // In case both T and U are arithmetic types, enforce that the
  // conversion is not lossy.
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;
  constexpr bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;
  constexpr bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;
  GTEST_COMPILE_ASSERT_(
      kTIsOther || kUIsOther ||
      (internal::LosslessArithmeticConvertible&lt;RawT, RawU&gt;::value),
      conversion_of_arithmetic_types_must_be_lossless);
  return MatcherCast&lt;T&gt;(matcher);
}

// A&lt;T&gt;() returns a matcher that matches any value of type T.
template &lt;typename T&gt;
Matcher&lt;T&gt; A();

// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION
// and MUST NOT BE USED IN USER CODE!!!
namespace internal {

// If the explanation is not empty, prints it to the ostream.
inline void PrintIfNotEmpty(const std::string&amp; explanation,
                            ::std::ostream* os) {
  if (explanation != "" &amp;&amp; os != nullptr) {
    *os &lt;&lt; ", " &lt;&lt; explanation;
  }
}

// Returns true if the given type name is easy to read by a human.
// This is used to decide whether printing the type of a value might
// be helpful.
inline bool IsReadableTypeName(const std::string&amp; type_name) {
  // We consider a type name readable if it's short or doesn't contain
  // a template or function type.
  return (type_name.length() &lt;= 20 ||
          type_name.find_first_of("&lt;(") == std::string::npos);
}

// Matches the value against the given matcher, prints the value and explains
// the match result to the listener. Returns the match result.
// 'listener' must not be NULL.
// Value cannot be passed by const reference, because some matchers take a
// non-const argument.
template &lt;typename Value, typename T&gt;
bool MatchPrintAndExplain(Value&amp; value, const Matcher&lt;T&gt;&amp; matcher,
                          MatchResultListener* listener) {
  if (!listener-&gt;IsInterested()) {
    // If the listener is not interested, we do not need to construct the
    // inner explanation.
    return matcher.Matches(value);
  }

  StringMatchResultListener inner_listener;
  const bool match = matcher.MatchAndExplain(value, &amp;inner_listener);

  UniversalPrint(value, listener-&gt;stream());
#if GTEST_HAS_RTTI
  const std::string&amp; type_name = GetTypeName&lt;Value&gt;();
  if (IsReadableTypeName(type_name))
    *listener-&gt;stream() &lt;&lt; " (of type " &lt;&lt; type_name &lt;&lt; ")";
#endif
  PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());

  return match;
}

// An internal helper class for doing compile-time loop on a tuple's
// fields.
template &lt;size_t N&gt;
class TuplePrefix {
 public:
  // TuplePrefix&lt;N&gt;::Matches(matcher_tuple, value_tuple) returns true
  // if and only if the first N fields of matcher_tuple matches
  // the first N fields of value_tuple, respectively.
  template &lt;typename MatcherTuple, typename ValueTuple&gt;
  static bool Matches(const MatcherTuple&amp; matcher_tuple,
                      const ValueTuple&amp; value_tuple) {
    return TuplePrefix&lt;N - 1&gt;::Matches(matcher_tuple, value_tuple) &amp;&amp;
           std::get&lt;N - 1&gt;(matcher_tuple).Matches(std::get&lt;N - 1&gt;(value_tuple));
  }

  // TuplePrefix&lt;N&gt;::ExplainMatchFailuresTo(matchers, values, os)
  // describes failures in matching the first N fields of matchers
  // against the first N fields of values.  If there is no failure,
  // nothing will be streamed to os.
  template &lt;typename MatcherTuple, typename ValueTuple&gt;
  static void ExplainMatchFailuresTo(const MatcherTuple&amp; matchers,
                                     const ValueTuple&amp; values,
                                     ::std::ostream* os) {
    // First, describes failures in the first N - 1 fields.
    TuplePrefix&lt;N - 1&gt;::ExplainMatchFailuresTo(matchers, values, os);

    // Then describes the failure (if any) in the (N - 1)-th (0-based)
    // field.
    typename std::tuple_element&lt;N - 1, MatcherTuple&gt;::type matcher =
        std::get&lt;N - 1&gt;(matchers);
    typedef typename std::tuple_element&lt;N - 1, ValueTuple&gt;::type Value;
    const Value&amp; value = std::get&lt;N - 1&gt;(values);
    StringMatchResultListener listener;
    if (!matcher.MatchAndExplain(value, &amp;listener)) {
      *os &lt;&lt; "  Expected arg #" &lt;&lt; N - 1 &lt;&lt; ": ";
      std::get&lt;N - 1&gt;(matchers).DescribeTo(os);
      *os &lt;&lt; "\n           Actual: ";
      // We remove the reference in type Value to prevent the
      // universal printer from printing the address of value, which
      // isn't interesting to the user most of the time.  The
      // matcher's MatchAndExplain() method handles the case when
      // the address is interesting.
      internal::UniversalPrint(value, os);
      PrintIfNotEmpty(listener.str(), os);
      *os &lt;&lt; "\n";
    }
  }
};

// The base case.
template &lt;&gt;
class TuplePrefix&lt;0&gt; {
 public:
  template &lt;typename MatcherTuple, typename ValueTuple&gt;
  static bool Matches(const MatcherTuple&amp; /* matcher_tuple */,
                      const ValueTuple&amp; /* value_tuple */) {
    return true;
  }

  template &lt;typename MatcherTuple, typename ValueTuple&gt;
  static void ExplainMatchFailuresTo(const MatcherTuple&amp; /* matchers */,
                                     const ValueTuple&amp; /* values */,
                                     ::std::ostream* /* os */) {}
};

// TupleMatches(matcher_tuple, value_tuple) returns true if and only if
// all matchers in matcher_tuple match the corresponding fields in
// value_tuple.  It is a compiler error if matcher_tuple and
// value_tuple have different number of fields or incompatible field
// types.
template &lt;typename MatcherTuple, typename ValueTuple&gt;
bool TupleMatches(const MatcherTuple&amp; matcher_tuple,
                  const ValueTuple&amp; value_tuple) {
  // Makes sure that matcher_tuple and value_tuple have the same
  // number of fields.
  GTEST_COMPILE_ASSERT_(std::tuple_size&lt;MatcherTuple&gt;::value ==
                            std::tuple_size&lt;ValueTuple&gt;::value,
                        matcher_and_value_have_different_numbers_of_fields);
  return TuplePrefix&lt;std::tuple_size&lt;ValueTuple&gt;::value&gt;::Matches(matcher_tuple,
                                                                  value_tuple);
}

// Describes failures in matching matchers against values.  If there
// is no failure, nothing will be streamed to os.
template &lt;typename MatcherTuple, typename ValueTuple&gt;
void ExplainMatchFailureTupleTo(const MatcherTuple&amp; matchers,
                                const ValueTuple&amp; values,
                                ::std::ostream* os) {
  TuplePrefix&lt;std::tuple_size&lt;MatcherTuple&gt;::value&gt;::ExplainMatchFailuresTo(
      matchers, values, os);
}

// TransformTupleValues and its helper.
//
// TransformTupleValuesHelper hides the internal machinery that
// TransformTupleValues uses to implement a tuple traversal.
template &lt;typename Tuple, typename Func, typename OutIter&gt;
class TransformTupleValuesHelper {
 private:
  typedef ::std::tuple_size&lt;Tuple&gt; TupleSize;

 public:
  // For each member of tuple 't', taken in order, evaluates '*out++ = f(t)'.
  // Returns the final value of 'out' in case the caller needs it.
  static OutIter Run(Func f, const Tuple&amp; t, OutIter out) {
    return IterateOverTuple&lt;Tuple, TupleSize::value&gt;()(f, t, out);
  }

 private:
  template &lt;typename Tup, size_t kRemainingSize&gt;
  struct IterateOverTuple {
    OutIter operator() (Func f, const Tup&amp; t, OutIter out) const {
      *out++ = f(::std::get&lt;TupleSize::value - kRemainingSize&gt;(t));
      return IterateOverTuple&lt;Tup, kRemainingSize - 1&gt;()(f, t, out);
    }
  };
  template &lt;typename Tup&gt;
  struct IterateOverTuple&lt;Tup, 0&gt; {
    OutIter operator() (Func /* f */, const Tup&amp; /* t */, OutIter out) const {
      return out;
    }
  };
};

// Successively invokes 'f(element)' on each element of the tuple 't',
// appending each result to the 'out' iterator. Returns the final value
// of 'out'.
template &lt;typename Tuple, typename Func, typename OutIter&gt;
OutIter TransformTupleValues(Func f, const Tuple&amp; t, OutIter out) {
  return TransformTupleValuesHelper&lt;Tuple, Func, OutIter&gt;::Run(f, t, out);
}

// Implements _, a matcher that matches any value of any
// type.  This is a polymorphic matcher, so we need a template type
// conversion operator to make it appearing as a Matcher&lt;T&gt; for any
// type T.
class AnythingMatcher {
 public:
  using is_gtest_matcher = void;

  template &lt;typename T&gt;
  bool MatchAndExplain(const T&amp; /* x */, std::ostream* /* listener */) const {
    return true;
  }
  void DescribeTo(std::ostream* os) const { *os &lt;&lt; "is anything"; }
  void DescribeNegationTo(::std::ostream* os) const {
    // This is mostly for completeness' sake, as it's not very useful
    // to write Not(A&lt;bool&gt;()).  However we cannot completely rule out
    // such a possibility, and it doesn't hurt to be prepared.
    *os &lt;&lt; "never matches";
  }
};

// Implements the polymorphic IsNull() matcher, which matches any raw or smart
// pointer that is NULL.
class IsNullMatcher {
 public:
  template &lt;typename Pointer&gt;
  bool MatchAndExplain(const Pointer&amp; p,
                       MatchResultListener* /* listener */) const {
    return p == nullptr;
  }

  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; "is NULL"; }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "isn't NULL";
  }
};

// Implements the polymorphic NotNull() matcher, which matches any raw or smart
// pointer that is not NULL.
class NotNullMatcher {
 public:
  template &lt;typename Pointer&gt;
  bool MatchAndExplain(const Pointer&amp; p,
                       MatchResultListener* /* listener */) const {
    return p != nullptr;
  }

  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; "isn't NULL"; }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "is NULL";
  }
};

// Ref(variable) matches any argument that is a reference to
// 'variable'.  This matcher is polymorphic as it can match any
// super type of the type of 'variable'.
//
// The RefMatcher template class implements Ref(variable).  It can
// only be instantiated with a reference type.  This prevents a user
// from mistakenly using Ref(x) to match a non-reference function
// argument.  For example, the following will righteously cause a
// compiler error:
//
//   int n;
//   Matcher&lt;int&gt; m1 = Ref(n);   // This won't compile.
//   Matcher&lt;int&amp;&gt; m2 = Ref(n);  // This will compile.
template &lt;typename T&gt;
class RefMatcher;

template &lt;typename T&gt;
class RefMatcher&lt;T&amp;&gt; {
  // Google Mock is a generic framework and thus needs to support
  // mocking any function types, including those that take non-const
  // reference arguments.  Therefore the template parameter T (and
  // Super below) can be instantiated to either a const type or a
  // non-const type.
 public:
  // RefMatcher() takes a T&amp; instead of const T&amp;, as we want the
  // compiler to catch using Ref(const_value) as a matcher for a
  // non-const reference.
  explicit RefMatcher(T&amp; x) : object_(x) {}  // NOLINT

  template &lt;typename Super&gt;
  operator Matcher&lt;Super&amp;&gt;() const {
    // By passing object_ (type T&amp;) to Impl(), which expects a Super&amp;,
    // we make sure that Super is a super type of T.  In particular,
    // this catches using Ref(const_value) as a matcher for a
    // non-const reference, as you cannot implicitly convert a const
    // reference to a non-const reference.
    return MakeMatcher(new Impl&lt;Super&gt;(object_));
  }

 private:
  template &lt;typename Super&gt;
  class Impl : public MatcherInterface&lt;Super&amp;&gt; {
   public:
    explicit Impl(Super&amp; x) : object_(x) {}  // NOLINT

    // MatchAndExplain() takes a Super&amp; (as opposed to const Super&amp;)
    // in order to match the interface MatcherInterface&lt;Super&amp;&gt;.
    bool MatchAndExplain(Super&amp; x,
                         MatchResultListener* listener) const override {
      *listener &lt;&lt; "which is located @" &lt;&lt; static_cast&lt;const void*&gt;(&amp;x);
      return &amp;x == &amp;object_;
    }

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "references the variable ";
      UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "does not reference the variable ";
      UniversalPrinter&lt;Super&amp;&gt;::Print(object_, os);
    }

   private:
    const Super&amp; object_;
  };

  T&amp; object_;
};

// Polymorphic helper functions for narrow and wide string matchers.
inline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {
  return String::CaseInsensitiveCStringEquals(lhs, rhs);
}

inline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,
                                         const wchar_t* rhs) {
  return String::CaseInsensitiveWideCStringEquals(lhs, rhs);
}

// String comparison for narrow or wide strings that can have embedded NUL
// characters.
template &lt;typename StringType&gt;
bool CaseInsensitiveStringEquals(const StringType&amp; s1,
                                 const StringType&amp; s2) {
  // Are the heads equal?
  if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {
    return false;
  }

  // Skip the equal heads.
  const typename StringType::value_type nul = 0;
  const size_t i1 = s1.find(nul), i2 = s2.find(nul);

  // Are we at the end of either s1 or s2?
  if (i1 == StringType::npos || i2 == StringType::npos) {
    return i1 == i2;
  }

  // Are the tails equal?
  return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));
}

// String matchers.

// Implements equality-based string matchers like StrEq, StrCaseNe, and etc.
template &lt;typename StringType&gt;
class StrEqualityMatcher {
 public:
  StrEqualityMatcher(StringType str, bool expect_eq, bool case_sensitive)
      : string_(std::move(str)),
        expect_eq_(expect_eq),
        case_sensitive_(case_sensitive) {}

#if GTEST_INTERNAL_HAS_STRING_VIEW
  bool MatchAndExplain(const internal::StringView&amp; s,
                       MatchResultListener* listener) const {
    // This should fail to compile if StringView is used with wide
    // strings.
    const StringType&amp; str = std::string(s);
    return MatchAndExplain(str, listener);
  }
#endif  // GTEST_INTERNAL_HAS_STRING_VIEW

  // Accepts pointer types, particularly:
  //   const char*
  //   char*
  //   const wchar_t*
  //   wchar_t*
  template &lt;typename CharType&gt;
  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
    if (s == nullptr) {
      return !expect_eq_;
    }
    return MatchAndExplain(StringType(s), listener);
  }

  // Matches anything that can convert to StringType.
  //
  // This is a template, not just a plain function with const StringType&amp;,
  // because StringView has some interfering non-explicit constructors.
  template &lt;typename MatcheeStringType&gt;
  bool MatchAndExplain(const MatcheeStringType&amp; s,
                       MatchResultListener* /* listener */) const {
    const StringType s2(s);
    const bool eq = case_sensitive_ ? s2 == string_ :
        CaseInsensitiveStringEquals(s2, string_);
    return expect_eq_ == eq;
  }

  void DescribeTo(::std::ostream* os) const {
    DescribeToHelper(expect_eq_, os);
  }

  void DescribeNegationTo(::std::ostream* os) const {
    DescribeToHelper(!expect_eq_, os);
  }

 private:
  void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {
    *os &lt;&lt; (expect_eq ? "is " : "isn't ");
    *os &lt;&lt; "equal to ";
    if (!case_sensitive_) {
      *os &lt;&lt; "(ignoring case) ";
    }
    UniversalPrint(string_, os);
  }

  const StringType string_;
  const bool expect_eq_;
  const bool case_sensitive_;
};

// Implements the polymorphic HasSubstr(substring) matcher, which
// can be used as a Matcher&lt;T&gt; as long as T can be converted to a
// string.
template &lt;typename StringType&gt;
class HasSubstrMatcher {
 public:
  explicit HasSubstrMatcher(const StringType&amp; substring)
      : substring_(substring) {}

#if GTEST_INTERNAL_HAS_STRING_VIEW
  bool MatchAndExplain(const internal::StringView&amp; s,
                       MatchResultListener* listener) const {
    // This should fail to compile if StringView is used with wide
    // strings.
    const StringType&amp; str = std::string(s);
    return MatchAndExplain(str, listener);
  }
#endif  // GTEST_INTERNAL_HAS_STRING_VIEW

  // Accepts pointer types, particularly:
  //   const char*
  //   char*
  //   const wchar_t*
  //   wchar_t*
  template &lt;typename CharType&gt;
  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
  }

  // Matches anything that can convert to StringType.
  //
  // This is a template, not just a plain function with const StringType&amp;,
  // because StringView has some interfering non-explicit constructors.
  template &lt;typename MatcheeStringType&gt;
  bool MatchAndExplain(const MatcheeStringType&amp; s,
                       MatchResultListener* /* listener */) const {
    return StringType(s).find(substring_) != StringType::npos;
  }

  // Describes what this matcher matches.
  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "has substring ";
    UniversalPrint(substring_, os);
  }

  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "has no substring ";
    UniversalPrint(substring_, os);
  }

 private:
  const StringType substring_;
};

// Implements the polymorphic StartsWith(substring) matcher, which
// can be used as a Matcher&lt;T&gt; as long as T can be converted to a
// string.
template &lt;typename StringType&gt;
class StartsWithMatcher {
 public:
  explicit StartsWithMatcher(const StringType&amp; prefix) : prefix_(prefix) {
  }

#if GTEST_INTERNAL_HAS_STRING_VIEW
  bool MatchAndExplain(const internal::StringView&amp; s,
                       MatchResultListener* listener) const {
    // This should fail to compile if StringView is used with wide
    // strings.
    const StringType&amp; str = std::string(s);
    return MatchAndExplain(str, listener);
  }
#endif  // GTEST_INTERNAL_HAS_STRING_VIEW

  // Accepts pointer types, particularly:
  //   const char*
  //   char*
  //   const wchar_t*
  //   wchar_t*
  template &lt;typename CharType&gt;
  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
  }

  // Matches anything that can convert to StringType.
  //
  // This is a template, not just a plain function with const StringType&amp;,
  // because StringView has some interfering non-explicit constructors.
  template &lt;typename MatcheeStringType&gt;
  bool MatchAndExplain(const MatcheeStringType&amp; s,
                       MatchResultListener* /* listener */) const {
    const StringType&amp; s2(s);
    return s2.length() &gt;= prefix_.length() &amp;&amp;
        s2.substr(0, prefix_.length()) == prefix_;
  }

  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "starts with ";
    UniversalPrint(prefix_, os);
  }

  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "doesn't start with ";
    UniversalPrint(prefix_, os);
  }

 private:
  const StringType prefix_;
};

// Implements the polymorphic EndsWith(substring) matcher, which
// can be used as a Matcher&lt;T&gt; as long as T can be converted to a
// string.
template &lt;typename StringType&gt;
class EndsWithMatcher {
 public:
  explicit EndsWithMatcher(const StringType&amp; suffix) : suffix_(suffix) {}

#if GTEST_INTERNAL_HAS_STRING_VIEW
  bool MatchAndExplain(const internal::StringView&amp; s,
                       MatchResultListener* listener) const {
    // This should fail to compile if StringView is used with wide
    // strings.
    const StringType&amp; str = std::string(s);
    return MatchAndExplain(str, listener);
  }
#endif  // GTEST_INTERNAL_HAS_STRING_VIEW

  // Accepts pointer types, particularly:
  //   const char*
  //   char*
  //   const wchar_t*
  //   wchar_t*
  template &lt;typename CharType&gt;
  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {
    return s != nullptr &amp;&amp; MatchAndExplain(StringType(s), listener);
  }

  // Matches anything that can convert to StringType.
  //
  // This is a template, not just a plain function with const StringType&amp;,
  // because StringView has some interfering non-explicit constructors.
  template &lt;typename MatcheeStringType&gt;
  bool MatchAndExplain(const MatcheeStringType&amp; s,
                       MatchResultListener* /* listener */) const {
    const StringType&amp; s2(s);
    return s2.length() &gt;= suffix_.length() &amp;&amp;
        s2.substr(s2.length() - suffix_.length()) == suffix_;
  }

  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "ends with ";
    UniversalPrint(suffix_, os);
  }

  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "doesn't end with ";
    UniversalPrint(suffix_, os);
  }

 private:
  const StringType suffix_;
};

// Implements a matcher that compares the two fields of a 2-tuple
// using one of the ==, &lt;=, &lt;, etc, operators.  The two fields being
// compared don't have to have the same type.
//
// The matcher defined here is polymorphic (for example, Eq() can be
// used to match a std::tuple&lt;int, short&gt;, a std::tuple&lt;const long&amp;, double&gt;,
// etc).  Therefore we use a template type conversion operator in the
// implementation.
template &lt;typename D, typename Op&gt;
class PairMatchBase {
 public:
  template &lt;typename T1, typename T2&gt;
  operator Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;() const {
    return Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;(new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;);
  }
  template &lt;typename T1, typename T2&gt;
  operator Matcher&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;() const {
    return MakeMatcher(new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;);
  }

 private:
  static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {  // NOLINT
    return os &lt;&lt; D::Desc();
  }

  template &lt;typename Tuple&gt;
  class Impl : public MatcherInterface&lt;Tuple&gt; {
   public:
    bool MatchAndExplain(Tuple args,
                         MatchResultListener* /* listener */) const override {
      return Op()(::std::get&lt;0&gt;(args), ::std::get&lt;1&gt;(args));
    }
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "are " &lt;&lt; GetDesc;
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "aren't " &lt;&lt; GetDesc;
    }
  };
};

class Eq2Matcher : public PairMatchBase&lt;Eq2Matcher, AnyEq&gt; {
 public:
  static const char* Desc() { return "an equal pair"; }
};
class Ne2Matcher : public PairMatchBase&lt;Ne2Matcher, AnyNe&gt; {
 public:
  static const char* Desc() { return "an unequal pair"; }
};
class Lt2Matcher : public PairMatchBase&lt;Lt2Matcher, AnyLt&gt; {
 public:
  static const char* Desc() { return "a pair where the first &lt; the second"; }
};
class Gt2Matcher : public PairMatchBase&lt;Gt2Matcher, AnyGt&gt; {
 public:
  static const char* Desc() { return "a pair where the first &gt; the second"; }
};
class Le2Matcher : public PairMatchBase&lt;Le2Matcher, AnyLe&gt; {
 public:
  static const char* Desc() { return "a pair where the first &lt;= the second"; }
};
class Ge2Matcher : public PairMatchBase&lt;Ge2Matcher, AnyGe&gt; {
 public:
  static const char* Desc() { return "a pair where the first &gt;= the second"; }
};

// Implements the Not(...) matcher for a particular argument type T.
// We do not nest it inside the NotMatcher class template, as that
// will prevent different instantiations of NotMatcher from sharing
// the same NotMatcherImpl&lt;T&gt; class.
template &lt;typename T&gt;
class NotMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
 public:
  explicit NotMatcherImpl(const Matcher&lt;T&gt;&amp; matcher)
      : matcher_(matcher) {}

  bool MatchAndExplain(const T&amp; x,
                       MatchResultListener* listener) const override {
    return !matcher_.MatchAndExplain(x, listener);
  }

  void DescribeTo(::std::ostream* os) const override {
    matcher_.DescribeNegationTo(os);
  }

  void DescribeNegationTo(::std::ostream* os) const override {
    matcher_.DescribeTo(os);
  }

 private:
  const Matcher&lt;T&gt; matcher_;
};

// Implements the Not(m) matcher, which matches a value that doesn't
// match matcher m.
template &lt;typename InnerMatcher&gt;
class NotMatcher {
 public:
  explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}

  // This template type conversion operator allows Not(m) to be used
  // to match any type m can match.
  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const {
    return Matcher&lt;T&gt;(new NotMatcherImpl&lt;T&gt;(SafeMatcherCast&lt;T&gt;(matcher_)));
  }

 private:
  InnerMatcher matcher_;
};

// Implements the AllOf(m1, m2) matcher for a particular argument type
// T. We do not nest it inside the BothOfMatcher class template, as
// that will prevent different instantiations of BothOfMatcher from
// sharing the same BothOfMatcherImpl&lt;T&gt; class.
template &lt;typename T&gt;
class AllOfMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
 public:
  explicit AllOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt; &gt; matchers)
      : matchers_(std::move(matchers)) {}

  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "(";
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      if (i != 0) *os &lt;&lt; ") and (";
      matchers_[i].DescribeTo(os);
    }
    *os &lt;&lt; ")";
  }

  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "(";
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      if (i != 0) *os &lt;&lt; ") or (";
      matchers_[i].DescribeNegationTo(os);
    }
    *os &lt;&lt; ")";
  }

  bool MatchAndExplain(const T&amp; x,
                       MatchResultListener* listener) const override {
    // If either matcher1_ or matcher2_ doesn't match x, we only need
    // to explain why one of them fails.
    std::string all_match_result;

    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      StringMatchResultListener slistener;
      if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {
        if (all_match_result.empty()) {
          all_match_result = slistener.str();
        } else {
          std::string result = slistener.str();
          if (!result.empty()) {
            all_match_result += ", and ";
            all_match_result += result;
          }
        }
      } else {
        *listener &lt;&lt; slistener.str();
        return false;
      }
    }

    // Otherwise we need to explain why *both* of them match.
    *listener &lt;&lt; all_match_result;
    return true;
  }

 private:
  const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_;
};

// VariadicMatcher is used for the variadic implementation of
// AllOf(m_1, m_2, ...) and AnyOf(m_1, m_2, ...).
// CombiningMatcher&lt;T&gt; is used to recursively combine the provided matchers
// (of type Args...).
template &lt;template &lt;typename T&gt; class CombiningMatcher, typename... Args&gt;
class VariadicMatcher {
 public:
  VariadicMatcher(const Args&amp;... matchers)  // NOLINT
      : matchers_(matchers...) {
    static_assert(sizeof...(Args) &gt; 0, "Must have at least one matcher.");
  }

  VariadicMatcher(const VariadicMatcher&amp;) = default;
  VariadicMatcher&amp; operator=(const VariadicMatcher&amp;) = delete;

  // This template type conversion operator allows an
  // VariadicMatcher&lt;Matcher1, Matcher2...&gt; object to match any type that
  // all of the provided matchers (Matcher1, Matcher2, ...) can match.
  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const {
    std::vector&lt;Matcher&lt;T&gt; &gt; values;
    CreateVariadicMatcher&lt;T&gt;(&amp;values, std::integral_constant&lt;size_t, 0&gt;());
    return Matcher&lt;T&gt;(new CombiningMatcher&lt;T&gt;(std::move(values)));
  }

 private:
  template &lt;typename T, size_t I&gt;
  void CreateVariadicMatcher(std::vector&lt;Matcher&lt;T&gt; &gt;* values,
                             std::integral_constant&lt;size_t, I&gt;) const {
    values-&gt;push_back(SafeMatcherCast&lt;T&gt;(std::get&lt;I&gt;(matchers_)));
    CreateVariadicMatcher&lt;T&gt;(values, std::integral_constant&lt;size_t, I + 1&gt;());
  }

  template &lt;typename T&gt;
  void CreateVariadicMatcher(
      std::vector&lt;Matcher&lt;T&gt; &gt;*,
      std::integral_constant&lt;size_t, sizeof...(Args)&gt;) const {}

  std::tuple&lt;Args...&gt; matchers_;
};

template &lt;typename... Args&gt;
using AllOfMatcher = VariadicMatcher&lt;AllOfMatcherImpl, Args...&gt;;

// Implements the AnyOf(m1, m2) matcher for a particular argument type
// T.  We do not nest it inside the AnyOfMatcher class template, as
// that will prevent different instantiations of AnyOfMatcher from
// sharing the same EitherOfMatcherImpl&lt;T&gt; class.
template &lt;typename T&gt;
class AnyOfMatcherImpl : public MatcherInterface&lt;const T&amp;&gt; {
 public:
  explicit AnyOfMatcherImpl(std::vector&lt;Matcher&lt;T&gt; &gt; matchers)
      : matchers_(std::move(matchers)) {}

  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "(";
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      if (i != 0) *os &lt;&lt; ") or (";
      matchers_[i].DescribeTo(os);
    }
    *os &lt;&lt; ")";
  }

  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "(";
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      if (i != 0) *os &lt;&lt; ") and (";
      matchers_[i].DescribeNegationTo(os);
    }
    *os &lt;&lt; ")";
  }

  bool MatchAndExplain(const T&amp; x,
                       MatchResultListener* listener) const override {
    std::string no_match_result;

    // If either matcher1_ or matcher2_ matches x, we just need to
    // explain why *one* of them matches.
    for (size_t i = 0; i &lt; matchers_.size(); ++i) {
      StringMatchResultListener slistener;
      if (matchers_[i].MatchAndExplain(x, &amp;slistener)) {
        *listener &lt;&lt; slistener.str();
        return true;
      } else {
        if (no_match_result.empty()) {
          no_match_result = slistener.str();
        } else {
          std::string result = slistener.str();
          if (!result.empty()) {
            no_match_result += ", and ";
            no_match_result += result;
          }
        }
      }
    }

    // Otherwise we need to explain why *both* of them fail.
    *listener &lt;&lt; no_match_result;
    return false;
  }

 private:
  const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_;
};

// AnyOfMatcher is used for the variadic implementation of AnyOf(m_1, m_2, ...).
template &lt;typename... Args&gt;
using AnyOfMatcher = VariadicMatcher&lt;AnyOfMatcherImpl, Args...&gt;;

// Wrapper for implementation of Any/AllOfArray().
template &lt;template &lt;class&gt; class MatcherImpl, typename T&gt;
class SomeOfArrayMatcher {
 public:
  // Constructs the matcher from a sequence of element values or
  // element matchers.
  template &lt;typename Iter&gt;
  SomeOfArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}

  template &lt;typename U&gt;
  operator Matcher&lt;U&gt;() const {  // NOLINT
    using RawU = typename std::decay&lt;U&gt;::type;
    std::vector&lt;Matcher&lt;RawU&gt;&gt; matchers;
    for (const auto&amp; matcher : matchers_) {
      matchers.push_back(MatcherCast&lt;RawU&gt;(matcher));
    }
    return Matcher&lt;U&gt;(new MatcherImpl&lt;RawU&gt;(std::move(matchers)));
  }

 private:
  const ::std::vector&lt;T&gt; matchers_;
};

template &lt;typename T&gt;
using AllOfArrayMatcher = SomeOfArrayMatcher&lt;AllOfMatcherImpl, T&gt;;

template &lt;typename T&gt;
using AnyOfArrayMatcher = SomeOfArrayMatcher&lt;AnyOfMatcherImpl, T&gt;;

// Used for implementing Truly(pred), which turns a predicate into a
// matcher.
template &lt;typename Predicate&gt;
class TrulyMatcher {
 public:
  explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}

  // This method template allows Truly(pred) to be used as a matcher
  // for type T where T is the argument type of predicate 'pred'.  The
  // argument is passed by reference as the predicate may be
  // interested in the address of the argument.
  template &lt;typename T&gt;
  bool MatchAndExplain(T&amp; x,  // NOLINT
                       MatchResultListener* listener) const {
    // Without the if-statement, MSVC sometimes warns about converting
    // a value to bool (warning 4800).
    //
    // We cannot write 'return !!predicate_(x);' as that doesn't work
    // when predicate_(x) returns a class convertible to bool but
    // having no operator!().
    if (predicate_(x))
      return true;
    *listener &lt;&lt; "didn't satisfy the given predicate";
    return false;
  }

  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "satisfies the given predicate";
  }

  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "doesn't satisfy the given predicate";
  }

 private:
  Predicate predicate_;
};

// Used for implementing Matches(matcher), which turns a matcher into
// a predicate.
template &lt;typename M&gt;
class MatcherAsPredicate {
 public:
  explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}

  // This template operator() allows Matches(m) to be used as a
  // predicate on type T where m is a matcher on type T.
  //
  // The argument x is passed by reference instead of by value, as
  // some matcher may be interested in its address (e.g. as in
  // Matches(Ref(n))(x)).
  template &lt;typename T&gt;
  bool operator()(const T&amp; x) const {
    // We let matcher_ commit to a particular type here instead of
    // when the MatcherAsPredicate object was constructed.  This
    // allows us to write Matches(m) where m is a polymorphic matcher
    // (e.g. Eq(5)).
    //
    // If we write Matcher&lt;T&gt;(matcher_).Matches(x) here, it won't
    // compile when matcher_ has type Matcher&lt;const T&amp;&gt;; if we write
    // Matcher&lt;const T&amp;&gt;(matcher_).Matches(x) here, it won't compile
    // when matcher_ has type Matcher&lt;T&gt;; if we just write
    // matcher_.Matches(x), it won't compile when matcher_ is
    // polymorphic, e.g. Eq(5).
    //
    // MatcherCast&lt;const T&amp;&gt;() is necessary for making the code work
    // in all of the above situations.
    return MatcherCast&lt;const T&amp;&gt;(matcher_).Matches(x);
  }

 private:
  M matcher_;
};

// For implementing ASSERT_THAT() and EXPECT_THAT().  The template
// argument M must be a type that can be converted to a matcher.
template &lt;typename M&gt;
class PredicateFormatterFromMatcher {
 public:
  explicit PredicateFormatterFromMatcher(M m) : matcher_(std::move(m)) {}

  // This template () operator allows a PredicateFormatterFromMatcher
  // object to act as a predicate-formatter suitable for using with
  // Google Test's EXPECT_PRED_FORMAT1() macro.
  template &lt;typename T&gt;
  AssertionResult operator()(const char* value_text, const T&amp; x) const {
    // We convert matcher_ to a Matcher&lt;const T&amp;&gt; *now* instead of
    // when the PredicateFormatterFromMatcher object was constructed,
    // as matcher_ may be polymorphic (e.g. NotNull()) and we won't
    // know which type to instantiate it to until we actually see the
    // type of x here.
    //
    // We write SafeMatcherCast&lt;const T&amp;&gt;(matcher_) instead of
    // Matcher&lt;const T&amp;&gt;(matcher_), as the latter won't compile when
    // matcher_ has type Matcher&lt;T&gt; (e.g. An&lt;int&gt;()).
    // We don't write MatcherCast&lt;const T&amp;&gt; either, as that allows
    // potentially unsafe downcasting of the matcher argument.
    const Matcher&lt;const T&amp;&gt; matcher = SafeMatcherCast&lt;const T&amp;&gt;(matcher_);

    // The expected path here is that the matcher should match (i.e. that most
    // tests pass) so optimize for this case.
    if (matcher.Matches(x)) {
      return AssertionSuccess();
    }

    ::std::stringstream ss;
    ss &lt;&lt; "Value of: " &lt;&lt; value_text &lt;&lt; "\n"
       &lt;&lt; "Expected: ";
    matcher.DescribeTo(&amp;ss);

    // Rerun the matcher to "PrintAndExplain" the failure.
    StringMatchResultListener listener;
    if (MatchPrintAndExplain(x, matcher, &amp;listener)) {
      ss &lt;&lt; "\n  The matcher failed on the initial attempt; but passed when "
            "rerun to generate the explanation.";
    }
    ss &lt;&lt; "\n  Actual: " &lt;&lt; listener.str();
    return AssertionFailure() &lt;&lt; ss.str();
  }

 private:
  const M matcher_;
};

// A helper function for converting a matcher to a predicate-formatter
// without the user needing to explicitly write the type.  This is
// used for implementing ASSERT_THAT() and EXPECT_THAT().
// Implementation detail: 'matcher' is received by-value to force decaying.
template &lt;typename M&gt;
inline PredicateFormatterFromMatcher&lt;M&gt;
MakePredicateFormatterFromMatcher(M matcher) {
  return PredicateFormatterFromMatcher&lt;M&gt;(std::move(matcher));
}

// Implements the polymorphic IsNan() matcher, which matches any floating type
// value that is Nan.
class IsNanMatcher {
 public:
  template &lt;typename FloatType&gt;
  bool MatchAndExplain(const FloatType&amp; f,
                       MatchResultListener* /* listener */) const {
    return (::std::isnan)(f);
  }

  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; "is NaN"; }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "isn't NaN";
  }
};

// Implements the polymorphic floating point equality matcher, which matches
// two float values using ULP-based approximation or, optionally, a
// user-specified epsilon.  The template is meant to be instantiated with
// FloatType being either float or double.
template &lt;typename FloatType&gt;
class FloatingEqMatcher {
 public:
  // Constructor for FloatingEqMatcher.
  // The matcher's input will be compared with expected.  The matcher treats two
  // NANs as equal if nan_eq_nan is true.  Otherwise, under IEEE standards,
  // equality comparisons between NANs will always return false.  We specify a
  // negative max_abs_error_ term to indicate that ULP-based approximation will
  // be used for comparison.
  FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :
    expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {
  }

  // Constructor that supports a user-specified max_abs_error that will be used
  // for comparison instead of ULP-based approximation.  The max absolute
  // should be non-negative.
  FloatingEqMatcher(FloatType expected, bool nan_eq_nan,
                    FloatType max_abs_error)
      : expected_(expected),
        nan_eq_nan_(nan_eq_nan),
        max_abs_error_(max_abs_error) {
    GTEST_CHECK_(max_abs_error &gt;= 0)
        &lt;&lt; ", where max_abs_error is" &lt;&lt; max_abs_error;
  }

  // Implements floating point equality matcher as a Matcher&lt;T&gt;.
  template &lt;typename T&gt;
  class Impl : public MatcherInterface&lt;T&gt; {
   public:
    Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)
        : expected_(expected),
          nan_eq_nan_(nan_eq_nan),
          max_abs_error_(max_abs_error) {}

    bool MatchAndExplain(T value,
                         MatchResultListener* listener) const override {
      const FloatingPoint&lt;FloatType&gt; actual(value), expected(expected_);

      // Compares NaNs first, if nan_eq_nan_ is true.
      if (actual.is_nan() || expected.is_nan()) {
        if (actual.is_nan() &amp;&amp; expected.is_nan()) {
          return nan_eq_nan_;
        }
        // One is nan; the other is not nan.
        return false;
      }
      if (HasMaxAbsError()) {
        // We perform an equality check so that inf will match inf, regardless
        // of error bounds.  If the result of value - expected_ would result in
        // overflow or if either value is inf, the default result is infinity,
        // which should only match if max_abs_error_ is also infinity.
        if (value == expected_) {
          return true;
        }

        const FloatType diff = value - expected_;
        if (::std::fabs(diff) &lt;= max_abs_error_) {
          return true;
        }

        if (listener-&gt;IsInterested()) {
          *listener &lt;&lt; "which is " &lt;&lt; diff &lt;&lt; " from " &lt;&lt; expected_;
        }
        return false;
      } else {
        return actual.AlmostEquals(expected);
      }
    }

    void DescribeTo(::std::ostream* os) const override {
      // os-&gt;precision() returns the previously set precision, which we
      // store to restore the ostream to its original configuration
      // after outputting.
      const ::std::streamsize old_precision = os-&gt;precision(
          ::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);
      if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {
        if (nan_eq_nan_) {
          *os &lt;&lt; "is NaN";
        } else {
          *os &lt;&lt; "never matches";
        }
      } else {
        *os &lt;&lt; "is approximately " &lt;&lt; expected_;
        if (HasMaxAbsError()) {
          *os &lt;&lt; " (absolute error &lt;= " &lt;&lt; max_abs_error_ &lt;&lt; ")";
        }
      }
      os-&gt;precision(old_precision);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      // As before, get original precision.
      const ::std::streamsize old_precision = os-&gt;precision(
          ::std::numeric_limits&lt;FloatType&gt;::digits10 + 2);
      if (FloatingPoint&lt;FloatType&gt;(expected_).is_nan()) {
        if (nan_eq_nan_) {
          *os &lt;&lt; "isn't NaN";
        } else {
          *os &lt;&lt; "is anything";
        }
      } else {
        *os &lt;&lt; "isn't approximately " &lt;&lt; expected_;
        if (HasMaxAbsError()) {
          *os &lt;&lt; " (absolute error &gt; " &lt;&lt; max_abs_error_ &lt;&lt; ")";
        }
      }
      // Restore original precision.
      os-&gt;precision(old_precision);
    }

   private:
    bool HasMaxAbsError() const {
      return max_abs_error_ &gt;= 0;
    }

    const FloatType expected_;
    const bool nan_eq_nan_;
    // max_abs_error will be used for value comparison when &gt;= 0.
    const FloatType max_abs_error_;
  };

  // The following 3 type conversion operators allow FloatEq(expected) and
  // NanSensitiveFloatEq(expected) to be used as a Matcher&lt;float&gt;, a
  // Matcher&lt;const float&amp;&gt;, or a Matcher&lt;float&amp;&gt;, but nothing else.
  operator Matcher&lt;FloatType&gt;() const {
    return MakeMatcher(
        new Impl&lt;FloatType&gt;(expected_, nan_eq_nan_, max_abs_error_));
  }

  operator Matcher&lt;const FloatType&amp;&gt;() const {
    return MakeMatcher(
        new Impl&lt;const FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));
  }

  operator Matcher&lt;FloatType&amp;&gt;() const {
    return MakeMatcher(
        new Impl&lt;FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_));
  }

 private:
  const FloatType expected_;
  const bool nan_eq_nan_;
  // max_abs_error will be used for value comparison when &gt;= 0.
  const FloatType max_abs_error_;
};

// A 2-tuple ("binary") wrapper around FloatingEqMatcher:
// FloatingEq2Matcher() matches (x, y) by matching FloatingEqMatcher(x, false)
// against y, and FloatingEq2Matcher(e) matches FloatingEqMatcher(x, false, e)
// against y. The former implements "Eq", the latter "Near". At present, there
// is no version that compares NaNs as equal.
template &lt;typename FloatType&gt;
class FloatingEq2Matcher {
 public:
  FloatingEq2Matcher() { Init(-1, false); }

  explicit FloatingEq2Matcher(bool nan_eq_nan) { Init(-1, nan_eq_nan); }

  explicit FloatingEq2Matcher(FloatType max_abs_error) {
    Init(max_abs_error, false);
  }

  FloatingEq2Matcher(FloatType max_abs_error, bool nan_eq_nan) {
    Init(max_abs_error, nan_eq_nan);
  }

  template &lt;typename T1, typename T2&gt;
  operator Matcher&lt;::std::tuple&lt;T1, T2&gt;&gt;() const {
    return MakeMatcher(
        new Impl&lt;::std::tuple&lt;T1, T2&gt;&gt;(max_abs_error_, nan_eq_nan_));
  }
  template &lt;typename T1, typename T2&gt;
  operator Matcher&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;() const {
    return MakeMatcher(
        new Impl&lt;const ::std::tuple&lt;T1, T2&gt;&amp;&gt;(max_abs_error_, nan_eq_nan_));
  }

 private:
  static ::std::ostream&amp; GetDesc(::std::ostream&amp; os) {  // NOLINT
    return os &lt;&lt; "an almost-equal pair";
  }

  template &lt;typename Tuple&gt;
  class Impl : public MatcherInterface&lt;Tuple&gt; {
   public:
    Impl(FloatType max_abs_error, bool nan_eq_nan) :
        max_abs_error_(max_abs_error),
        nan_eq_nan_(nan_eq_nan) {}

    bool MatchAndExplain(Tuple args,
                         MatchResultListener* listener) const override {
      if (max_abs_error_ == -1) {
        FloatingEqMatcher&lt;FloatType&gt; fm(::std::get&lt;0&gt;(args), nan_eq_nan_);
        return static_cast&lt;Matcher&lt;FloatType&gt;&gt;(fm).MatchAndExplain(
            ::std::get&lt;1&gt;(args), listener);
      } else {
        FloatingEqMatcher&lt;FloatType&gt; fm(::std::get&lt;0&gt;(args), nan_eq_nan_,
                                        max_abs_error_);
        return static_cast&lt;Matcher&lt;FloatType&gt;&gt;(fm).MatchAndExplain(
            ::std::get&lt;1&gt;(args), listener);
      }
    }
    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "are " &lt;&lt; GetDesc;
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "aren't " &lt;&lt; GetDesc;
    }

   private:
    FloatType max_abs_error_;
    const bool nan_eq_nan_;
  };

  void Init(FloatType max_abs_error_val, bool nan_eq_nan_val) {
    max_abs_error_ = max_abs_error_val;
    nan_eq_nan_ = nan_eq_nan_val;
  }
  FloatType max_abs_error_;
  bool nan_eq_nan_;
};

// Implements the Pointee(m) matcher for matching a pointer whose
// pointee matches matcher m.  The pointer can be either raw or smart.
template &lt;typename InnerMatcher&gt;
class PointeeMatcher {
 public:
  explicit PointeeMatcher(const InnerMatcher&amp; matcher) : matcher_(matcher) {}

  // This type conversion operator template allows Pointee(m) to be
  // used as a matcher for any pointer type whose pointee type is
  // compatible with the inner matcher, where type Pointer can be
  // either a raw pointer or a smart pointer.
  //
  // The reason we do this instead of relying on
  // MakePolymorphicMatcher() is that the latter is not flexible
  // enough for implementing the DescribeTo() method of Pointee().
  template &lt;typename Pointer&gt;
  operator Matcher&lt;Pointer&gt;() const {
    return Matcher&lt;Pointer&gt;(new Impl&lt;const Pointer&amp;&gt;(matcher_));
  }

 private:
  // The monomorphic implementation that works for a particular pointer type.
  template &lt;typename Pointer&gt;
  class Impl : public MatcherInterface&lt;Pointer&gt; {
   public:
    using Pointee =
        typename std::pointer_traits&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(
            Pointer)&gt;::element_type;

    explicit Impl(const InnerMatcher&amp; matcher)
        : matcher_(MatcherCast&lt;const Pointee&amp;&gt;(matcher)) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "points to a value that ";
      matcher_.DescribeTo(os);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "does not point to a value that ";
      matcher_.DescribeTo(os);
    }

    bool MatchAndExplain(Pointer pointer,
                         MatchResultListener* listener) const override {
      if (GetRawPointer(pointer) == nullptr) return false;

      *listener &lt;&lt; "which points to ";
      return MatchPrintAndExplain(*pointer, matcher_, listener);
    }

   private:
    const Matcher&lt;const Pointee&amp;&gt; matcher_;
  };

  const InnerMatcher matcher_;
};

// Implements the Pointer(m) matcher
// Implements the Pointer(m) matcher for matching a pointer that matches matcher
// m.  The pointer can be either raw or smart, and will match `m` against the
// raw pointer.
template &lt;typename InnerMatcher&gt;
class PointerMatcher {
 public:
  explicit PointerMatcher(const InnerMatcher&amp; matcher) : matcher_(matcher) {}

  // This type conversion operator template allows Pointer(m) to be
  // used as a matcher for any pointer type whose pointer type is
  // compatible with the inner matcher, where type PointerType can be
  // either a raw pointer or a smart pointer.
  //
  // The reason we do this instead of relying on
  // MakePolymorphicMatcher() is that the latter is not flexible
  // enough for implementing the DescribeTo() method of Pointer().
  template &lt;typename PointerType&gt;
  operator Matcher&lt;PointerType&gt;() const {  // NOLINT
    return Matcher&lt;PointerType&gt;(new Impl&lt;const PointerType&amp;&gt;(matcher_));
  }

 private:
  // The monomorphic implementation that works for a particular pointer type.
  template &lt;typename PointerType&gt;
  class Impl : public MatcherInterface&lt;PointerType&gt; {
   public:
    using Pointer =
        const typename std::pointer_traits&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(
            PointerType)&gt;::element_type*;

    explicit Impl(const InnerMatcher&amp; matcher)
        : matcher_(MatcherCast&lt;Pointer&gt;(matcher)) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "is a pointer that ";
      matcher_.DescribeTo(os);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "is not a pointer that ";
      matcher_.DescribeTo(os);
    }

    bool MatchAndExplain(PointerType pointer,
                         MatchResultListener* listener) const override {
      *listener &lt;&lt; "which is a pointer that ";
      Pointer p = GetRawPointer(pointer);
      return MatchPrintAndExplain(p, matcher_, listener);
    }

   private:
    Matcher&lt;Pointer&gt; matcher_;
  };

  const InnerMatcher matcher_;
};

#if GTEST_HAS_RTTI
// Implements the WhenDynamicCastTo&lt;T&gt;(m) matcher that matches a pointer or
// reference that matches inner_matcher when dynamic_cast&lt;T&gt; is applied.
// The result of dynamic_cast&lt;To&gt; is forwarded to the inner matcher.
// If To is a pointer and the cast fails, the inner matcher will receive NULL.
// If To is a reference and the cast fails, this matcher returns false
// immediately.
template &lt;typename To&gt;
class WhenDynamicCastToMatcherBase {
 public:
  explicit WhenDynamicCastToMatcherBase(const Matcher&lt;To&gt;&amp; matcher)
      : matcher_(matcher) {}

  void DescribeTo(::std::ostream* os) const {
    GetCastTypeDescription(os);
    matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(::std::ostream* os) const {
    GetCastTypeDescription(os);
    matcher_.DescribeNegationTo(os);
  }

 protected:
  const Matcher&lt;To&gt; matcher_;

  static std::string GetToName() {
    return GetTypeName&lt;To&gt;();
  }

 private:
  static void GetCastTypeDescription(::std::ostream* os) {
    *os &lt;&lt; "when dynamic_cast to " &lt;&lt; GetToName() &lt;&lt; ", ";
  }
};

// Primary template.
// To is a pointer. Cast and forward the result.
template &lt;typename To&gt;
class WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase&lt;To&gt; {
 public:
  explicit WhenDynamicCastToMatcher(const Matcher&lt;To&gt;&amp; matcher)
      : WhenDynamicCastToMatcherBase&lt;To&gt;(matcher) {}

  template &lt;typename From&gt;
  bool MatchAndExplain(From from, MatchResultListener* listener) const {
    To to = dynamic_cast&lt;To&gt;(from);
    return MatchPrintAndExplain(to, this-&gt;matcher_, listener);
  }
};

// Specialize for references.
// In this case we return false if the dynamic_cast fails.
template &lt;typename To&gt;
class WhenDynamicCastToMatcher&lt;To&amp;&gt; : public WhenDynamicCastToMatcherBase&lt;To&amp;&gt; {
 public:
  explicit WhenDynamicCastToMatcher(const Matcher&lt;To&amp;&gt;&amp; matcher)
      : WhenDynamicCastToMatcherBase&lt;To&amp;&gt;(matcher) {}

  template &lt;typename From&gt;
  bool MatchAndExplain(From&amp; from, MatchResultListener* listener) const {
    // We don't want an std::bad_cast here, so do the cast with pointers.
    To* to = dynamic_cast&lt;To*&gt;(&amp;from);
    if (to == nullptr) {
      *listener &lt;&lt; "which cannot be dynamic_cast to " &lt;&lt; this-&gt;GetToName();
      return false;
    }
    return MatchPrintAndExplain(*to, this-&gt;matcher_, listener);
  }
};
#endif  // GTEST_HAS_RTTI

// Implements the Field() matcher for matching a field (i.e. member
// variable) of an object.
template &lt;typename Class, typename FieldType&gt;
class FieldMatcher {
 public:
  FieldMatcher(FieldType Class::*field,
               const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)
      : field_(field), matcher_(matcher), whose_field_("whose given field ") {}

  FieldMatcher(const std::string&amp; field_name, FieldType Class::*field,
               const Matcher&lt;const FieldType&amp;&gt;&amp; matcher)
      : field_(field),
        matcher_(matcher),
        whose_field_("whose field `" + field_name + "` ") {}

  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "is an object " &lt;&lt; whose_field_;
    matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "is an object " &lt;&lt; whose_field_;
    matcher_.DescribeNegationTo(os);
  }

  template &lt;typename T&gt;
  bool MatchAndExplain(const T&amp; value, MatchResultListener* listener) const {
    // FIXME: The dispatch on std::is_pointer was introduced as a workaround for
    // a compiler bug, and can now be removed.
    return MatchAndExplainImpl(
        typename std::is_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type(),
        value, listener);
  }

 private:
  bool MatchAndExplainImpl(std::false_type /* is_not_pointer */,
                           const Class&amp; obj,
                           MatchResultListener* listener) const {
    *listener &lt;&lt; whose_field_ &lt;&lt; "is ";
    return MatchPrintAndExplain(obj.*field_, matcher_, listener);
  }

  bool MatchAndExplainImpl(std::true_type /* is_pointer */, const Class* p,
                           MatchResultListener* listener) const {
    if (p == nullptr) return false;

    *listener &lt;&lt; "which points to an object ";
    // Since *p has a field, it must be a class/struct/union type and
    // thus cannot be a pointer.  Therefore we pass false_type() as
    // the first argument.
    return MatchAndExplainImpl(std::false_type(), *p, listener);
  }

  const FieldType Class::*field_;
  const Matcher&lt;const FieldType&amp;&gt; matcher_;

  // Contains either "whose given field " if the name of the field is unknown
  // or "whose field `name_of_field` " if the name is known.
  const std::string whose_field_;
};

// Implements the Property() matcher for matching a property
// (i.e. return value of a getter method) of an object.
//
// Property is a const-qualified member function of Class returning
// PropertyType.
template &lt;typename Class, typename PropertyType, typename Property&gt;
class PropertyMatcher {
 public:
  typedef const PropertyType&amp; RefToConstProperty;

  PropertyMatcher(Property property, const Matcher&lt;RefToConstProperty&gt;&amp; matcher)
      : property_(property),
        matcher_(matcher),
        whose_property_("whose given property ") {}

  PropertyMatcher(const std::string&amp; property_name, Property property,
                  const Matcher&lt;RefToConstProperty&gt;&amp; matcher)
      : property_(property),
        matcher_(matcher),
        whose_property_("whose property `" + property_name + "` ") {}

  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "is an object " &lt;&lt; whose_property_;
    matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "is an object " &lt;&lt; whose_property_;
    matcher_.DescribeNegationTo(os);
  }

  template &lt;typename T&gt;
  bool MatchAndExplain(const T&amp;value, MatchResultListener* listener) const {
    return MatchAndExplainImpl(
        typename std::is_pointer&lt;typename std::remove_const&lt;T&gt;::type&gt;::type(),
        value, listener);
  }

 private:
  bool MatchAndExplainImpl(std::false_type /* is_not_pointer */,
                           const Class&amp; obj,
                           MatchResultListener* listener) const {
    *listener &lt;&lt; whose_property_ &lt;&lt; "is ";
    // Cannot pass the return value (for example, int) to MatchPrintAndExplain,
    // which takes a non-const reference as argument.
    RefToConstProperty result = (obj.*property_)();
    return MatchPrintAndExplain(result, matcher_, listener);
  }

  bool MatchAndExplainImpl(std::true_type /* is_pointer */, const Class* p,
                           MatchResultListener* listener) const {
    if (p == nullptr) return false;

    *listener &lt;&lt; "which points to an object ";
    // Since *p has a property method, it must be a class/struct/union
    // type and thus cannot be a pointer.  Therefore we pass
    // false_type() as the first argument.
    return MatchAndExplainImpl(std::false_type(), *p, listener);
  }

  Property property_;
  const Matcher&lt;RefToConstProperty&gt; matcher_;

  // Contains either "whose given property " if the name of the property is
  // unknown or "whose property `name_of_property` " if the name is known.
  const std::string whose_property_;
};

// Type traits specifying various features of different functors for ResultOf.
// The default template specifies features for functor objects.
template &lt;typename Functor&gt;
struct CallableTraits {
  typedef Functor StorageType;

  static void CheckIsValid(Functor /* functor */) {}

  template &lt;typename T&gt;
  static auto Invoke(Functor f, const T&amp; arg) -&gt; decltype(f(arg)) {
    return f(arg);
  }
};

// Specialization for function pointers.
template &lt;typename ArgType, typename ResType&gt;
struct CallableTraits&lt;ResType(*)(ArgType)&gt; {
  typedef ResType ResultType;
  typedef ResType(*StorageType)(ArgType);

  static void CheckIsValid(ResType(*f)(ArgType)) {
    GTEST_CHECK_(f != nullptr)
        &lt;&lt; "NULL function pointer is passed into ResultOf().";
  }
  template &lt;typename T&gt;
  static ResType Invoke(ResType(*f)(ArgType), T arg) {
    return (*f)(arg);
  }
};

// Implements the ResultOf() matcher for matching a return value of a
// unary function of an object.
template &lt;typename Callable, typename InnerMatcher&gt;
class ResultOfMatcher {
 public:
  ResultOfMatcher(Callable callable, InnerMatcher matcher)
      : callable_(std::move(callable)), matcher_(std::move(matcher)) {
    CallableTraits&lt;Callable&gt;::CheckIsValid(callable_);
  }

  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const {
    return Matcher&lt;T&gt;(new Impl&lt;const T&amp;&gt;(callable_, matcher_));
  }

 private:
  typedef typename CallableTraits&lt;Callable&gt;::StorageType CallableStorageType;

  template &lt;typename T&gt;
  class Impl : public MatcherInterface&lt;T&gt; {
    using ResultType = decltype(CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(
        std::declval&lt;CallableStorageType&gt;(), std::declval&lt;T&gt;()));

   public:
    template &lt;typename M&gt;
    Impl(const CallableStorageType&amp; callable, const M&amp; matcher)
        : callable_(callable), matcher_(MatcherCast&lt;ResultType&gt;(matcher)) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "is mapped by the given callable to a value that ";
      matcher_.DescribeTo(os);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "is mapped by the given callable to a value that ";
      matcher_.DescribeNegationTo(os);
    }

    bool MatchAndExplain(T obj, MatchResultListener* listener) const override {
      *listener &lt;&lt; "which is mapped by the given callable to ";
      // Cannot pass the return value directly to MatchPrintAndExplain, which
      // takes a non-const reference as argument.
      // Also, specifying template argument explicitly is needed because T could
      // be a non-const reference (e.g. Matcher&lt;Uncopyable&amp;&gt;).
      ResultType result =
          CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(callable_, obj);
      return MatchPrintAndExplain(result, matcher_, listener);
    }

   private:
    // Functors often define operator() as non-const method even though
    // they are actually stateless. But we need to use them even when
    // 'this' is a const pointer. It's the user's responsibility not to
    // use stateful callables with ResultOf(), which doesn't guarantee
    // how many times the callable will be invoked.
    mutable CallableStorageType callable_;
    const Matcher&lt;ResultType&gt; matcher_;
  };  // class Impl

  const CallableStorageType callable_;
  const InnerMatcher matcher_;
};

// Implements a matcher that checks the size of an STL-style container.
template &lt;typename SizeMatcher&gt;
class SizeIsMatcher {
 public:
  explicit SizeIsMatcher(const SizeMatcher&amp; size_matcher)
       : size_matcher_(size_matcher) {
  }

  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(new Impl&lt;const Container&amp;&gt;(size_matcher_));
  }

  template &lt;typename Container&gt;
  class Impl : public MatcherInterface&lt;Container&gt; {
   public:
    using SizeType = decltype(std::declval&lt;Container&gt;().size());
    explicit Impl(const SizeMatcher&amp; size_matcher)
        : size_matcher_(MatcherCast&lt;SizeType&gt;(size_matcher)) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "size ";
      size_matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "size ";
      size_matcher_.DescribeNegationTo(os);
    }

    bool MatchAndExplain(Container container,
                         MatchResultListener* listener) const override {
      SizeType size = container.size();
      StringMatchResultListener size_listener;
      const bool result = size_matcher_.MatchAndExplain(size, &amp;size_listener);
      *listener
          &lt;&lt; "whose size " &lt;&lt; size &lt;&lt; (result ? " matches" : " doesn't match");
      PrintIfNotEmpty(size_listener.str(), listener-&gt;stream());
      return result;
    }

   private:
    const Matcher&lt;SizeType&gt; size_matcher_;
  };

 private:
  const SizeMatcher size_matcher_;
};

// Implements a matcher that checks the begin()..end() distance of an STL-style
// container.
template &lt;typename DistanceMatcher&gt;
class BeginEndDistanceIsMatcher {
 public:
  explicit BeginEndDistanceIsMatcher(const DistanceMatcher&amp; distance_matcher)
      : distance_matcher_(distance_matcher) {}

  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(new Impl&lt;const Container&amp;&gt;(distance_matcher_));
  }

  template &lt;typename Container&gt;
  class Impl : public MatcherInterface&lt;Container&gt; {
   public:
    typedef internal::StlContainerView&lt;
        GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt; ContainerView;
    typedef typename std::iterator_traits&lt;
        typename ContainerView::type::const_iterator&gt;::difference_type
        DistanceType;
    explicit Impl(const DistanceMatcher&amp; distance_matcher)
        : distance_matcher_(MatcherCast&lt;DistanceType&gt;(distance_matcher)) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "distance between begin() and end() ";
      distance_matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "distance between begin() and end() ";
      distance_matcher_.DescribeNegationTo(os);
    }

    bool MatchAndExplain(Container container,
                         MatchResultListener* listener) const override {
      using std::begin;
      using std::end;
      DistanceType distance = std::distance(begin(container), end(container));
      StringMatchResultListener distance_listener;
      const bool result =
          distance_matcher_.MatchAndExplain(distance, &amp;distance_listener);
      *listener &lt;&lt; "whose distance between begin() and end() " &lt;&lt; distance
                &lt;&lt; (result ? " matches" : " doesn't match");
      PrintIfNotEmpty(distance_listener.str(), listener-&gt;stream());
      return result;
    }

   private:
    const Matcher&lt;DistanceType&gt; distance_matcher_;
  };

 private:
  const DistanceMatcher distance_matcher_;
};

// Implements an equality matcher for any STL-style container whose elements
// support ==. This matcher is like Eq(), but its failure explanations provide
// more detailed information that is useful when the container is used as a set.
// The failure message reports elements that are in one of the operands but not
// the other. The failure messages do not report duplicate or out-of-order
// elements in the containers (which don't properly matter to sets, but can
// occur if the containers are vectors or lists, for example).
//
// Uses the container's const_iterator, value_type, operator ==,
// begin(), and end().
template &lt;typename Container&gt;
class ContainerEqMatcher {
 public:
  typedef internal::StlContainerView&lt;Container&gt; View;
  typedef typename View::type StlContainer;
  typedef typename View::const_reference StlContainerReference;

  static_assert(!std::is_const&lt;Container&gt;::value,
                "Container type must not be const");
  static_assert(!std::is_reference&lt;Container&gt;::value,
                "Container type must not be a reference");

  // We make a copy of expected in case the elements in it are modified
  // after this matcher is created.
  explicit ContainerEqMatcher(const Container&amp; expected)
      : expected_(View::Copy(expected)) {}

  void DescribeTo(::std::ostream* os) const {
    *os &lt;&lt; "equals ";
    UniversalPrint(expected_, os);
  }
  void DescribeNegationTo(::std::ostream* os) const {
    *os &lt;&lt; "does not equal ";
    UniversalPrint(expected_, os);
  }

  template &lt;typename LhsContainer&gt;
  bool MatchAndExplain(const LhsContainer&amp; lhs,
                       MatchResultListener* listener) const {
    typedef internal::StlContainerView&lt;
        typename std::remove_const&lt;LhsContainer&gt;::type&gt;
        LhsView;
    typedef typename LhsView::type LhsStlContainer;
    StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
    if (lhs_stl_container == expected_)
      return true;

    ::std::ostream* const os = listener-&gt;stream();
    if (os != nullptr) {
      // Something is different. Check for extra values first.
      bool printed_header = false;
      for (typename LhsStlContainer::const_iterator it =
               lhs_stl_container.begin();
           it != lhs_stl_container.end(); ++it) {
        if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==
            expected_.end()) {
          if (printed_header) {
            *os &lt;&lt; ", ";
          } else {
            *os &lt;&lt; "which has these unexpected elements: ";
            printed_header = true;
          }
          UniversalPrint(*it, os);
        }
      }

      // Now check for missing values.
      bool printed_header2 = false;
      for (typename StlContainer::const_iterator it = expected_.begin();
           it != expected_.end(); ++it) {
        if (internal::ArrayAwareFind(
                lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==
            lhs_stl_container.end()) {
          if (printed_header2) {
            *os &lt;&lt; ", ";
          } else {
            *os &lt;&lt; (printed_header ? ",\nand" : "which")
                &lt;&lt; " doesn't have these expected elements: ";
            printed_header2 = true;
          }
          UniversalPrint(*it, os);
        }
      }
    }

    return false;
  }

 private:
  const StlContainer expected_;
};

// A comparator functor that uses the &lt; operator to compare two values.
struct LessComparator {
  template &lt;typename T, typename U&gt;
  bool operator()(const T&amp; lhs, const U&amp; rhs) const { return lhs &lt; rhs; }
};

// Implements WhenSortedBy(comparator, container_matcher).
template &lt;typename Comparator, typename ContainerMatcher&gt;
class WhenSortedByMatcher {
 public:
  WhenSortedByMatcher(const Comparator&amp; comparator,
                      const ContainerMatcher&amp; matcher)
      : comparator_(comparator), matcher_(matcher) {}

  template &lt;typename LhsContainer&gt;
  operator Matcher&lt;LhsContainer&gt;() const {
    return MakeMatcher(new Impl&lt;LhsContainer&gt;(comparator_, matcher_));
  }

  template &lt;typename LhsContainer&gt;
  class Impl : public MatcherInterface&lt;LhsContainer&gt; {
   public:
    typedef internal::StlContainerView&lt;
         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt; LhsView;
    typedef typename LhsView::type LhsStlContainer;
    typedef typename LhsView::const_reference LhsStlContainerReference;
    // Transforms std::pair&lt;const Key, Value&gt; into std::pair&lt;Key, Value&gt;
    // so that we can match associative containers.
    typedef typename RemoveConstFromKey&lt;
        typename LhsStlContainer::value_type&gt;::type LhsValue;

    Impl(const Comparator&amp; comparator, const ContainerMatcher&amp; matcher)
        : comparator_(comparator), matcher_(matcher) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "(when sorted) ";
      matcher_.DescribeTo(os);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "(when sorted) ";
      matcher_.DescribeNegationTo(os);
    }

    bool MatchAndExplain(LhsContainer lhs,
                         MatchResultListener* listener) const override {
      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
      ::std::vector&lt;LhsValue&gt; sorted_container(lhs_stl_container.begin(),
                                               lhs_stl_container.end());
      ::std::sort(
           sorted_container.begin(), sorted_container.end(), comparator_);

      if (!listener-&gt;IsInterested()) {
        // If the listener is not interested, we do not need to
        // construct the inner explanation.
        return matcher_.Matches(sorted_container);
      }

      *listener &lt;&lt; "which is ";
      UniversalPrint(sorted_container, listener-&gt;stream());
      *listener &lt;&lt; " when sorted";

      StringMatchResultListener inner_listener;
      const bool match = matcher_.MatchAndExplain(sorted_container,
                                                  &amp;inner_listener);
      PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
      return match;
    }

   private:
    const Comparator comparator_;
    const Matcher&lt;const ::std::vector&lt;LhsValue&gt;&amp;&gt; matcher_;

    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
  };

 private:
  const Comparator comparator_;
  const ContainerMatcher matcher_;
};

// Implements Pointwise(tuple_matcher, rhs_container).  tuple_matcher
// must be able to be safely cast to Matcher&lt;std::tuple&lt;const T1&amp;, const
// T2&amp;&gt; &gt;, where T1 and T2 are the types of elements in the LHS
// container and the RHS container respectively.
template &lt;typename TupleMatcher, typename RhsContainer&gt;
class PointwiseMatcher {
  GTEST_COMPILE_ASSERT_(
      !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)&gt;::value,
      use_UnorderedPointwise_with_hash_tables);

 public:
  typedef internal::StlContainerView&lt;RhsContainer&gt; RhsView;
  typedef typename RhsView::type RhsStlContainer;
  typedef typename RhsStlContainer::value_type RhsValue;

  static_assert(!std::is_const&lt;RhsContainer&gt;::value,
                "RhsContainer type must not be const");
  static_assert(!std::is_reference&lt;RhsContainer&gt;::value,
                "RhsContainer type must not be a reference");

  // Like ContainerEq, we make a copy of rhs in case the elements in
  // it are modified after this matcher is created.
  PointwiseMatcher(const TupleMatcher&amp; tuple_matcher, const RhsContainer&amp; rhs)
      : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {}

  template &lt;typename LhsContainer&gt;
  operator Matcher&lt;LhsContainer&gt;() const {
    GTEST_COMPILE_ASSERT_(
        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt;::value,
        use_UnorderedPointwise_with_hash_tables);

    return Matcher&lt;LhsContainer&gt;(
        new Impl&lt;const LhsContainer&amp;&gt;(tuple_matcher_, rhs_));
  }

  template &lt;typename LhsContainer&gt;
  class Impl : public MatcherInterface&lt;LhsContainer&gt; {
   public:
    typedef internal::StlContainerView&lt;
         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)&gt; LhsView;
    typedef typename LhsView::type LhsStlContainer;
    typedef typename LhsView::const_reference LhsStlContainerReference;
    typedef typename LhsStlContainer::value_type LhsValue;
    // We pass the LHS value and the RHS value to the inner matcher by
    // reference, as they may be expensive to copy.  We must use tuple
    // instead of pair here, as a pair cannot hold references (C++ 98,
    // 20.2.2 [lib.pairs]).
    typedef ::std::tuple&lt;const LhsValue&amp;, const RhsValue&amp;&gt; InnerMatcherArg;

    Impl(const TupleMatcher&amp; tuple_matcher, const RhsStlContainer&amp; rhs)
        // mono_tuple_matcher_ holds a monomorphic version of the tuple matcher.
        : mono_tuple_matcher_(SafeMatcherCast&lt;InnerMatcherArg&gt;(tuple_matcher)),
          rhs_(rhs) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "contains " &lt;&lt; rhs_.size()
          &lt;&lt; " values, where each value and its corresponding value in ";
      UniversalPrinter&lt;RhsStlContainer&gt;::Print(rhs_, os);
      *os &lt;&lt; " ";
      mono_tuple_matcher_.DescribeTo(os);
    }
    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "doesn't contain exactly " &lt;&lt; rhs_.size()
          &lt;&lt; " values, or contains a value x at some index i"
          &lt;&lt; " where x and the i-th value of ";
      UniversalPrint(rhs_, os);
      *os &lt;&lt; " ";
      mono_tuple_matcher_.DescribeNegationTo(os);
    }

    bool MatchAndExplain(LhsContainer lhs,
                         MatchResultListener* listener) const override {
      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);
      const size_t actual_size = lhs_stl_container.size();
      if (actual_size != rhs_.size()) {
        *listener &lt;&lt; "which contains " &lt;&lt; actual_size &lt;&lt; " values";
        return false;
      }

      typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();
      typename RhsStlContainer::const_iterator right = rhs_.begin();
      for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {
        if (listener-&gt;IsInterested()) {
          StringMatchResultListener inner_listener;
          // Create InnerMatcherArg as a temporarily object to avoid it outlives
          // *left and *right. Dereference or the conversion to `const T&amp;` may
          // return temp objects, e.g for vector&lt;bool&gt;.
          if (!mono_tuple_matcher_.MatchAndExplain(
                  InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),
                                  ImplicitCast_&lt;const RhsValue&amp;&gt;(*right)),
                  &amp;inner_listener)) {
            *listener &lt;&lt; "where the value pair (";
            UniversalPrint(*left, listener-&gt;stream());
            *listener &lt;&lt; ", ";
            UniversalPrint(*right, listener-&gt;stream());
            *listener &lt;&lt; ") at index #" &lt;&lt; i &lt;&lt; " don't match";
            PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
            return false;
          }
        } else {
          if (!mono_tuple_matcher_.Matches(
                  InnerMatcherArg(ImplicitCast_&lt;const LhsValue&amp;&gt;(*left),
                                  ImplicitCast_&lt;const RhsValue&amp;&gt;(*right))))
            return false;
        }
      }

      return true;
    }

   private:
    const Matcher&lt;InnerMatcherArg&gt; mono_tuple_matcher_;
    const RhsStlContainer rhs_;
  };

 private:
  const TupleMatcher tuple_matcher_;
  const RhsStlContainer rhs_;
};

// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.
template &lt;typename Container&gt;
class QuantifierMatcherImpl : public MatcherInterface&lt;Container&gt; {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
  typedef StlContainerView&lt;RawContainer&gt; View;
  typedef typename View::type StlContainer;
  typedef typename View::const_reference StlContainerReference;
  typedef typename StlContainer::value_type Element;

  template &lt;typename InnerMatcher&gt;
  explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)
      : inner_matcher_(
           testing::SafeMatcherCast&lt;const Element&amp;&gt;(inner_matcher)) {}

  // Checks whether:
  // * All elements in the container match, if all_elements_should_match.
  // * Any element in the container matches, if !all_elements_should_match.
  bool MatchAndExplainImpl(bool all_elements_should_match,
                           Container container,
                           MatchResultListener* listener) const {
    StlContainerReference stl_container = View::ConstReference(container);
    size_t i = 0;
    for (typename StlContainer::const_iterator it = stl_container.begin();
         it != stl_container.end(); ++it, ++i) {
      StringMatchResultListener inner_listener;
      const bool matches = inner_matcher_.MatchAndExplain(*it, &amp;inner_listener);

      if (matches != all_elements_should_match) {
        *listener &lt;&lt; "whose element #" &lt;&lt; i
                  &lt;&lt; (matches ? " matches" : " doesn't match");
        PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
        return !all_elements_should_match;
      }
    }
    return all_elements_should_match;
  }

 protected:
  const Matcher&lt;const Element&amp;&gt; inner_matcher_;
};

// Implements Contains(element_matcher) for the given argument type Container.
// Symmetric to EachMatcherImpl.
template &lt;typename Container&gt;
class ContainsMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {
 public:
  template &lt;typename InnerMatcher&gt;
  explicit ContainsMatcherImpl(InnerMatcher inner_matcher)
      : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}

  // Describes what this matcher does.
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "contains at least one element that ";
    this-&gt;inner_matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "doesn't contain any element that ";
    this-&gt;inner_matcher_.DescribeTo(os);
  }

  bool MatchAndExplain(Container container,
                       MatchResultListener* listener) const override {
    return this-&gt;MatchAndExplainImpl(false, container, listener);
  }
};

// Implements Each(element_matcher) for the given argument type Container.
// Symmetric to ContainsMatcherImpl.
template &lt;typename Container&gt;
class EachMatcherImpl : public QuantifierMatcherImpl&lt;Container&gt; {
 public:
  template &lt;typename InnerMatcher&gt;
  explicit EachMatcherImpl(InnerMatcher inner_matcher)
      : QuantifierMatcherImpl&lt;Container&gt;(inner_matcher) {}

  // Describes what this matcher does.
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "only contains elements that ";
    this-&gt;inner_matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "contains some element that ";
    this-&gt;inner_matcher_.DescribeNegationTo(os);
  }

  bool MatchAndExplain(Container container,
                       MatchResultListener* listener) const override {
    return this-&gt;MatchAndExplainImpl(true, container, listener);
  }
};

// Implements polymorphic Contains(element_matcher).
template &lt;typename M&gt;
class ContainsMatcher {
 public:
  explicit ContainsMatcher(M m) : inner_matcher_(m) {}

  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(
        new ContainsMatcherImpl&lt;const Container&amp;&gt;(inner_matcher_));
  }

 private:
  const M inner_matcher_;
};

// Implements polymorphic Each(element_matcher).
template &lt;typename M&gt;
class EachMatcher {
 public:
  explicit EachMatcher(M m) : inner_matcher_(m) {}

  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(
        new EachMatcherImpl&lt;const Container&amp;&gt;(inner_matcher_));
  }

 private:
  const M inner_matcher_;
};

struct Rank1 {};
struct Rank0 : Rank1 {};

namespace pair_getters {
using std::get;
template &lt;typename T&gt;
auto First(T&amp; x, Rank1) -&gt; decltype(get&lt;0&gt;(x)) {  // NOLINT
  return get&lt;0&gt;(x);
}
template &lt;typename T&gt;
auto First(T&amp; x, Rank0) -&gt; decltype((x.first)) {  // NOLINT
  return x.first;
}

template &lt;typename T&gt;
auto Second(T&amp; x, Rank1) -&gt; decltype(get&lt;1&gt;(x)) {  // NOLINT
  return get&lt;1&gt;(x);
}
template &lt;typename T&gt;
auto Second(T&amp; x, Rank0) -&gt; decltype((x.second)) {  // NOLINT
  return x.second;
}
}  // namespace pair_getters

// Implements Key(inner_matcher) for the given argument pair type.
// Key(inner_matcher) matches an std::pair whose 'first' field matches
// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an
// std::map that contains at least one element whose key is &gt;= 5.
template &lt;typename PairType&gt;
class KeyMatcherImpl : public MatcherInterface&lt;PairType&gt; {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
  typedef typename RawPairType::first_type KeyType;

  template &lt;typename InnerMatcher&gt;
  explicit KeyMatcherImpl(InnerMatcher inner_matcher)
      : inner_matcher_(
          testing::SafeMatcherCast&lt;const KeyType&amp;&gt;(inner_matcher)) {
  }

  // Returns true if and only if 'key_value.first' (the key) matches the inner
  // matcher.
  bool MatchAndExplain(PairType key_value,
                       MatchResultListener* listener) const override {
    StringMatchResultListener inner_listener;
    const bool match = inner_matcher_.MatchAndExplain(
        pair_getters::First(key_value, Rank0()), &amp;inner_listener);
    const std::string explanation = inner_listener.str();
    if (explanation != "") {
      *listener &lt;&lt; "whose first field is a value " &lt;&lt; explanation;
    }
    return match;
  }

  // Describes what this matcher does.
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "has a key that ";
    inner_matcher_.DescribeTo(os);
  }

  // Describes what the negation of this matcher does.
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "doesn't have a key that ";
    inner_matcher_.DescribeTo(os);
  }

 private:
  const Matcher&lt;const KeyType&amp;&gt; inner_matcher_;
};

// Implements polymorphic Key(matcher_for_key).
template &lt;typename M&gt;
class KeyMatcher {
 public:
  explicit KeyMatcher(M m) : matcher_for_key_(m) {}

  template &lt;typename PairType&gt;
  operator Matcher&lt;PairType&gt;() const {
    return Matcher&lt;PairType&gt;(
        new KeyMatcherImpl&lt;const PairType&amp;&gt;(matcher_for_key_));
  }

 private:
  const M matcher_for_key_;
};

// Implements polymorphic Address(matcher_for_address).
template &lt;typename InnerMatcher&gt;
class AddressMatcher {
 public:
  explicit AddressMatcher(InnerMatcher m) : matcher_(m) {}

  template &lt;typename Type&gt;
  operator Matcher&lt;Type&gt;() const {  // NOLINT
    return Matcher&lt;Type&gt;(new Impl&lt;const Type&amp;&gt;(matcher_));
  }

 private:
  // The monomorphic implementation that works for a particular object type.
  template &lt;typename Type&gt;
  class Impl : public MatcherInterface&lt;Type&gt; {
   public:
    using Address = const GTEST_REMOVE_REFERENCE_AND_CONST_(Type) *;
    explicit Impl(const InnerMatcher&amp; matcher)
        : matcher_(MatcherCast&lt;Address&gt;(matcher)) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "has address that ";
      matcher_.DescribeTo(os);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "does not have address that ";
      matcher_.DescribeTo(os);
    }

    bool MatchAndExplain(Type object,
                         MatchResultListener* listener) const override {
      *listener &lt;&lt; "which has address ";
      Address address = std::addressof(object);
      return MatchPrintAndExplain(address, matcher_, listener);
    }

   private:
    const Matcher&lt;Address&gt; matcher_;
  };
  const InnerMatcher matcher_;
};

// Implements Pair(first_matcher, second_matcher) for the given argument pair
// type with its two matchers. See Pair() function below.
template &lt;typename PairType&gt;
class PairMatcherImpl : public MatcherInterface&lt;PairType&gt; {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;
  typedef typename RawPairType::first_type FirstType;
  typedef typename RawPairType::second_type SecondType;

  template &lt;typename FirstMatcher, typename SecondMatcher&gt;
  PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)
      : first_matcher_(
            testing::SafeMatcherCast&lt;const FirstType&amp;&gt;(first_matcher)),
        second_matcher_(
            testing::SafeMatcherCast&lt;const SecondType&amp;&gt;(second_matcher)) {
  }

  // Describes what this matcher does.
  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "has a first field that ";
    first_matcher_.DescribeTo(os);
    *os &lt;&lt; ", and has a second field that ";
    second_matcher_.DescribeTo(os);
  }

  // Describes what the negation of this matcher does.
  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "has a first field that ";
    first_matcher_.DescribeNegationTo(os);
    *os &lt;&lt; ", or has a second field that ";
    second_matcher_.DescribeNegationTo(os);
  }

  // Returns true if and only if 'a_pair.first' matches first_matcher and
  // 'a_pair.second' matches second_matcher.
  bool MatchAndExplain(PairType a_pair,
                       MatchResultListener* listener) const override {
    if (!listener-&gt;IsInterested()) {
      // If the listener is not interested, we don't need to construct the
      // explanation.
      return first_matcher_.Matches(pair_getters::First(a_pair, Rank0())) &amp;&amp;
             second_matcher_.Matches(pair_getters::Second(a_pair, Rank0()));
    }
    StringMatchResultListener first_inner_listener;
    if (!first_matcher_.MatchAndExplain(pair_getters::First(a_pair, Rank0()),
                                        &amp;first_inner_listener)) {
      *listener &lt;&lt; "whose first field does not match";
      PrintIfNotEmpty(first_inner_listener.str(), listener-&gt;stream());
      return false;
    }
    StringMatchResultListener second_inner_listener;
    if (!second_matcher_.MatchAndExplain(pair_getters::Second(a_pair, Rank0()),
                                         &amp;second_inner_listener)) {
      *listener &lt;&lt; "whose second field does not match";
      PrintIfNotEmpty(second_inner_listener.str(), listener-&gt;stream());
      return false;
    }
    ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),
                   listener);
    return true;
  }

 private:
  void ExplainSuccess(const std::string&amp; first_explanation,
                      const std::string&amp; second_explanation,
                      MatchResultListener* listener) const {
    *listener &lt;&lt; "whose both fields match";
    if (first_explanation != "") {
      *listener &lt;&lt; ", where the first field is a value " &lt;&lt; first_explanation;
    }
    if (second_explanation != "") {
      *listener &lt;&lt; ", ";
      if (first_explanation != "") {
        *listener &lt;&lt; "and ";
      } else {
        *listener &lt;&lt; "where ";
      }
      *listener &lt;&lt; "the second field is a value " &lt;&lt; second_explanation;
    }
  }

  const Matcher&lt;const FirstType&amp;&gt; first_matcher_;
  const Matcher&lt;const SecondType&amp;&gt; second_matcher_;
};

// Implements polymorphic Pair(first_matcher, second_matcher).
template &lt;typename FirstMatcher, typename SecondMatcher&gt;
class PairMatcher {
 public:
  PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)
      : first_matcher_(first_matcher), second_matcher_(second_matcher) {}

  template &lt;typename PairType&gt;
  operator Matcher&lt;PairType&gt; () const {
    return Matcher&lt;PairType&gt;(
        new PairMatcherImpl&lt;const PairType&amp;&gt;(first_matcher_, second_matcher_));
  }

 private:
  const FirstMatcher first_matcher_;
  const SecondMatcher second_matcher_;
};

template &lt;typename T, size_t... I&gt;
auto UnpackStructImpl(const T&amp; t, IndexSequence&lt;I...&gt;, int)
    -&gt; decltype(std::tie(get&lt;I&gt;(t)...)) {
  static_assert(std::tuple_size&lt;T&gt;::value == sizeof...(I),
                "Number of arguments doesn't match the number of fields.");
  return std::tie(get&lt;I&gt;(t)...);
}

#if defined(__cpp_structured_bindings) &amp;&amp; __cpp_structured_bindings &gt;= 201606
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;1&gt;, char) {
  const auto&amp; [a] = t;
  return std::tie(a);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;2&gt;, char) {
  const auto&amp; [a, b] = t;
  return std::tie(a, b);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;3&gt;, char) {
  const auto&amp; [a, b, c] = t;
  return std::tie(a, b, c);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;4&gt;, char) {
  const auto&amp; [a, b, c, d] = t;
  return std::tie(a, b, c, d);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;5&gt;, char) {
  const auto&amp; [a, b, c, d, e] = t;
  return std::tie(a, b, c, d, e);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;6&gt;, char) {
  const auto&amp; [a, b, c, d, e, f] = t;
  return std::tie(a, b, c, d, e, f);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;7&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g] = t;
  return std::tie(a, b, c, d, e, f, g);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;8&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h] = t;
  return std::tie(a, b, c, d, e, f, g, h);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;9&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h, i] = t;
  return std::tie(a, b, c, d, e, f, g, h, i);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;10&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h, i, j] = t;
  return std::tie(a, b, c, d, e, f, g, h, i, j);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;11&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k] = t;
  return std::tie(a, b, c, d, e, f, g, h, i, j, k);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;12&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l] = t;
  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;13&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l, m] = t;
  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;14&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l, m, n] = t;
  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;15&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o] = t;
  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
}
template &lt;typename T&gt;
auto UnpackStructImpl(const T&amp; t, MakeIndexSequence&lt;16&gt;, char) {
  const auto&amp; [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p] = t;
  return std::tie(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
}
#endif  // defined(__cpp_structured_bindings)

template &lt;size_t I, typename T&gt;
auto UnpackStruct(const T&amp; t)
    -&gt; decltype((UnpackStructImpl)(t, MakeIndexSequence&lt;I&gt;{}, 0)) {
  return (UnpackStructImpl)(t, MakeIndexSequence&lt;I&gt;{}, 0);
}

// Helper function to do comma folding in C++11.
// The array ensures left-to-right order of evaluation.
// Usage: VariadicExpand({expr...});
template &lt;typename T, size_t N&gt;
void VariadicExpand(const T (&amp;)[N]) {}

template &lt;typename Struct, typename StructSize&gt;
class FieldsAreMatcherImpl;

template &lt;typename Struct, size_t... I&gt;
class FieldsAreMatcherImpl&lt;Struct, IndexSequence&lt;I...&gt;&gt;
    : public MatcherInterface&lt;Struct&gt; {
  using UnpackedType =
      decltype(UnpackStruct&lt;sizeof...(I)&gt;(std::declval&lt;const Struct&amp;&gt;()));
  using MatchersType = std::tuple&lt;
      Matcher&lt;const typename std::tuple_element&lt;I, UnpackedType&gt;::type&amp;&gt;...&gt;;

 public:
  template &lt;typename Inner&gt;
  explicit FieldsAreMatcherImpl(const Inner&amp; matchers)
      : matchers_(testing::SafeMatcherCast&lt;
                  const typename std::tuple_element&lt;I, UnpackedType&gt;::type&amp;&gt;(
            std::get&lt;I&gt;(matchers))...) {}

  void DescribeTo(::std::ostream* os) const override {
    const char* separator = "";
    VariadicExpand(
        {(*os &lt;&lt; separator &lt;&lt; "has field #" &lt;&lt; I &lt;&lt; " that ",
          std::get&lt;I&gt;(matchers_).DescribeTo(os), separator = ", and ")...});
  }

  void DescribeNegationTo(::std::ostream* os) const override {
    const char* separator = "";
    VariadicExpand({(*os &lt;&lt; separator &lt;&lt; "has field #" &lt;&lt; I &lt;&lt; " that ",
                     std::get&lt;I&gt;(matchers_).DescribeNegationTo(os),
                     separator = ", or ")...});
  }

  bool MatchAndExplain(Struct t, MatchResultListener* listener) const override {
    return MatchInternal((UnpackStruct&lt;sizeof...(I)&gt;)(t), listener);
  }

 private:
  bool MatchInternal(UnpackedType tuple, MatchResultListener* listener) const {
    if (!listener-&gt;IsInterested()) {
      // If the listener is not interested, we don't need to construct the
      // explanation.
      bool good = true;
      VariadicExpand({good = good &amp;&amp; std::get&lt;I&gt;(matchers_).Matches(
                                         std::get&lt;I&gt;(tuple))...});
      return good;
    }

    size_t failed_pos = ~size_t{};

    std::vector&lt;StringMatchResultListener&gt; inner_listener(sizeof...(I));

    VariadicExpand(
        {failed_pos == ~size_t{} &amp;&amp; !std::get&lt;I&gt;(matchers_).MatchAndExplain(
                                        std::get&lt;I&gt;(tuple), &amp;inner_listener[I])
             ? failed_pos = I
             : 0 ...});
    if (failed_pos != ~size_t{}) {
      *listener &lt;&lt; "whose field #" &lt;&lt; failed_pos &lt;&lt; " does not match";
      PrintIfNotEmpty(inner_listener[failed_pos].str(), listener-&gt;stream());
      return false;
    }

    *listener &lt;&lt; "whose all elements match";
    const char* separator = ", where";
    for (size_t index = 0; index &lt; sizeof...(I); ++index) {
      const std::string str = inner_listener[index].str();
      if (!str.empty()) {
        *listener &lt;&lt; separator &lt;&lt; " field #" &lt;&lt; index &lt;&lt; " is a value " &lt;&lt; str;
        separator = ", and";
      }
    }

    return true;
  }

  MatchersType matchers_;
};

template &lt;typename... Inner&gt;
class FieldsAreMatcher {
 public:
  explicit FieldsAreMatcher(Inner... inner) : matchers_(std::move(inner)...) {}

  template &lt;typename Struct&gt;
  operator Matcher&lt;Struct&gt;() const {  // NOLINT
    return Matcher&lt;Struct&gt;(
        new FieldsAreMatcherImpl&lt;const Struct&amp;, IndexSequenceFor&lt;Inner...&gt;&gt;(
            matchers_));
  }

 private:
  std::tuple&lt;Inner...&gt; matchers_;
};

// Implements ElementsAre() and ElementsAreArray().
template &lt;typename Container&gt;
class ElementsAreMatcherImpl : public MatcherInterface&lt;Container&gt; {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
  typedef internal::StlContainerView&lt;RawContainer&gt; View;
  typedef typename View::type StlContainer;
  typedef typename View::const_reference StlContainerReference;
  typedef typename StlContainer::value_type Element;

  // Constructs the matcher from a sequence of element values or
  // element matchers.
  template &lt;typename InputIter&gt;
  ElementsAreMatcherImpl(InputIter first, InputIter last) {
    while (first != last) {
      matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first++));
    }
  }

  // Describes what this matcher does.
  void DescribeTo(::std::ostream* os) const override {
    if (count() == 0) {
      *os &lt;&lt; "is empty";
    } else if (count() == 1) {
      *os &lt;&lt; "has 1 element that ";
      matchers_[0].DescribeTo(os);
    } else {
      *os &lt;&lt; "has " &lt;&lt; Elements(count()) &lt;&lt; " where\n";
      for (size_t i = 0; i != count(); ++i) {
        *os &lt;&lt; "element #" &lt;&lt; i &lt;&lt; " ";
        matchers_[i].DescribeTo(os);
        if (i + 1 &lt; count()) {
          *os &lt;&lt; ",\n";
        }
      }
    }
  }

  // Describes what the negation of this matcher does.
  void DescribeNegationTo(::std::ostream* os) const override {
    if (count() == 0) {
      *os &lt;&lt; "isn't empty";
      return;
    }

    *os &lt;&lt; "doesn't have " &lt;&lt; Elements(count()) &lt;&lt; ", or\n";
    for (size_t i = 0; i != count(); ++i) {
      *os &lt;&lt; "element #" &lt;&lt; i &lt;&lt; " ";
      matchers_[i].DescribeNegationTo(os);
      if (i + 1 &lt; count()) {
        *os &lt;&lt; ", or\n";
      }
    }
  }

  bool MatchAndExplain(Container container,
                       MatchResultListener* listener) const override {
    // To work with stream-like "containers", we must only walk
    // through the elements in one pass.

    const bool listener_interested = listener-&gt;IsInterested();

    // explanations[i] is the explanation of the element at index i.
    ::std::vector&lt;std::string&gt; explanations(count());
    StlContainerReference stl_container = View::ConstReference(container);
    typename StlContainer::const_iterator it = stl_container.begin();
    size_t exam_pos = 0;
    bool mismatch_found = false;  // Have we found a mismatched element yet?

    // Go through the elements and matchers in pairs, until we reach
    // the end of either the elements or the matchers, or until we find a
    // mismatch.
    for (; it != stl_container.end() &amp;&amp; exam_pos != count(); ++it, ++exam_pos) {
      bool match;  // Does the current element match the current matcher?
      if (listener_interested) {
        StringMatchResultListener s;
        match = matchers_[exam_pos].MatchAndExplain(*it, &amp;s);
        explanations[exam_pos] = s.str();
      } else {
        match = matchers_[exam_pos].Matches(*it);
      }

      if (!match) {
        mismatch_found = true;
        break;
      }
    }
    // If mismatch_found is true, 'exam_pos' is the index of the mismatch.

    // Find how many elements the actual container has.  We avoid
    // calling size() s.t. this code works for stream-like "containers"
    // that don't define size().
    size_t actual_count = exam_pos;
    for (; it != stl_container.end(); ++it) {
      ++actual_count;
    }

    if (actual_count != count()) {
      // The element count doesn't match.  If the container is empty,
      // there's no need to explain anything as Google Mock already
      // prints the empty container.  Otherwise we just need to show
      // how many elements there actually are.
      if (listener_interested &amp;&amp; (actual_count != 0)) {
        *listener &lt;&lt; "which has " &lt;&lt; Elements(actual_count);
      }
      return false;
    }

    if (mismatch_found) {
      // The element count matches, but the exam_pos-th element doesn't match.
      if (listener_interested) {
        *listener &lt;&lt; "whose element #" &lt;&lt; exam_pos &lt;&lt; " doesn't match";
        PrintIfNotEmpty(explanations[exam_pos], listener-&gt;stream());
      }
      return false;
    }

    // Every element matches its expectation.  We need to explain why
    // (the obvious ones can be skipped).
    if (listener_interested) {
      bool reason_printed = false;
      for (size_t i = 0; i != count(); ++i) {
        const std::string&amp; s = explanations[i];
        if (!s.empty()) {
          if (reason_printed) {
            *listener &lt;&lt; ",\nand ";
          }
          *listener &lt;&lt; "whose element #" &lt;&lt; i &lt;&lt; " matches, " &lt;&lt; s;
          reason_printed = true;
        }
      }
    }
    return true;
  }

 private:
  static Message Elements(size_t count) {
    return Message() &lt;&lt; count &lt;&lt; (count == 1 ? " element" : " elements");
  }

  size_t count() const { return matchers_.size(); }

  ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; matchers_;
};

// Connectivity matrix of (elements X matchers), in element-major order.
// Initially, there are no edges.
// Use NextGraph() to iterate over all possible edge configurations.
// Use Randomize() to generate a random edge configuration.
class GTEST_API_ MatchMatrix {
 public:
  MatchMatrix(size_t num_elements, size_t num_matchers)
      : num_elements_(num_elements),
        num_matchers_(num_matchers),
        matched_(num_elements_* num_matchers_, 0) {
  }

<span style = "background-color:#fdd">  size_t LhsSize() const { return num_elements_; }
  size_t RhsSize() const { return num_matchers_; }
  bool HasEdge(size_t ilhs, size_t irhs) const {
    return matched_[SpaceIndex(ilhs, irhs)] == 1;
  }</span>
  void SetEdge(size_t ilhs, size_t irhs, bool b) {
    matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;
  }

  // Treating the connectivity matrix as a (LhsSize()*RhsSize())-bit number,
  // adds 1 to that number; returns false if incrementing the graph left it
  // empty.
  bool NextGraph();

  void Randomize();

  std::string DebugString() const;

 private:
<span style = "background-color:#fdd">  size_t SpaceIndex(size_t ilhs, size_t irhs) const {
    return ilhs * num_matchers_ + irhs;
  }</span>

  size_t num_elements_;
  size_t num_matchers_;

  // Each element is a char interpreted as bool. They are stored as a
  // flattened array in lhs-major order, use 'SpaceIndex()' to translate
  // a (ilhs, irhs) matrix coordinate into an offset.
  ::std::vector&lt;char&gt; matched_;
};

typedef ::std::pair&lt;size_t, size_t&gt; ElementMatcherPair;
typedef ::std::vector&lt;ElementMatcherPair&gt; ElementMatcherPairs;

// Returns a maximum bipartite matching for the specified graph 'g'.
// The matching is represented as a vector of {element, matcher} pairs.
GTEST_API_ ElementMatcherPairs
FindMaxBipartiteMatching(const MatchMatrix&amp; g);

struct UnorderedMatcherRequire {
  enum Flags {
    Superset = 1 &lt;&lt; 0,
    Subset = 1 &lt;&lt; 1,
    ExactMatch = Superset | Subset,
  };
};

// Untyped base class for implementing UnorderedElementsAre.  By
// putting logic that's not specific to the element type here, we
// reduce binary bloat and increase compilation speed.
class GTEST_API_ UnorderedElementsAreMatcherImplBase {
 protected:
  explicit UnorderedElementsAreMatcherImplBase(
      UnorderedMatcherRequire::Flags matcher_flags)
      : match_flags_(matcher_flags) {}

  // A vector of matcher describers, one for each element matcher.
  // Does not own the describers (and thus can be used only when the
  // element matchers are alive).
  typedef ::std::vector&lt;const MatcherDescriberInterface*&gt; MatcherDescriberVec;

  // Describes this UnorderedElementsAre matcher.
  void DescribeToImpl(::std::ostream* os) const;

  // Describes the negation of this UnorderedElementsAre matcher.
  void DescribeNegationToImpl(::std::ostream* os) const;

  bool VerifyMatchMatrix(const ::std::vector&lt;std::string&gt;&amp; element_printouts,
                         const MatchMatrix&amp; matrix,
                         MatchResultListener* listener) const;

  bool FindPairing(const MatchMatrix&amp; matrix,
                   MatchResultListener* listener) const;

  MatcherDescriberVec&amp; matcher_describers() {
    return matcher_describers_;
  }

<span style = "background-color:#fdd">  static Message Elements(size_t n) {
    return Message() &lt;&lt; n &lt;&lt; " element" &lt;&lt; (n == 1 ? "" : "s");
  }</span>

<span style = "background-color:#fdd">  UnorderedMatcherRequire::Flags match_flags() const { return match_flags_; }</span>

 private:
  UnorderedMatcherRequire::Flags match_flags_;
  MatcherDescriberVec matcher_describers_;
};

// Implements UnorderedElementsAre, UnorderedElementsAreArray, IsSubsetOf, and
// IsSupersetOf.
template &lt;typename Container&gt;
class UnorderedElementsAreMatcherImpl
    : public MatcherInterface&lt;Container&gt;,
      public UnorderedElementsAreMatcherImplBase {
 public:
  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
  typedef internal::StlContainerView&lt;RawContainer&gt; View;
  typedef typename View::type StlContainer;
  typedef typename View::const_reference StlContainerReference;
  typedef typename StlContainer::const_iterator StlContainerConstIterator;
  typedef typename StlContainer::value_type Element;

  template &lt;typename InputIter&gt;
  UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags matcher_flags,
                                  InputIter first, InputIter last)
      : UnorderedElementsAreMatcherImplBase(matcher_flags) {
    for (; first != last; ++first) {
      matchers_.push_back(MatcherCast&lt;const Element&amp;&gt;(*first));
    }
    for (const auto&amp; m : matchers_) {
      matcher_describers().push_back(m.GetDescriber());
    }
  }

  // Describes what this matcher does.
  void DescribeTo(::std::ostream* os) const override {
    return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);
  }

  // Describes what the negation of this matcher does.
  void DescribeNegationTo(::std::ostream* os) const override {
    return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);
  }

  bool MatchAndExplain(Container container,
                       MatchResultListener* listener) const override {
    StlContainerReference stl_container = View::ConstReference(container);
    ::std::vector&lt;std::string&gt; element_printouts;
    MatchMatrix matrix =
        AnalyzeElements(stl_container.begin(), stl_container.end(),
                        &amp;element_printouts, listener);

    if (matrix.LhsSize() == 0 &amp;&amp; matrix.RhsSize() == 0) {
      return true;
    }

    if (match_flags() == UnorderedMatcherRequire::ExactMatch) {
      if (matrix.LhsSize() != matrix.RhsSize()) {
        // The element count doesn't match.  If the container is empty,
        // there's no need to explain anything as Google Mock already
        // prints the empty container. Otherwise we just need to show
        // how many elements there actually are.
        if (matrix.LhsSize() != 0 &amp;&amp; listener-&gt;IsInterested()) {
          *listener &lt;&lt; "which has " &lt;&lt; Elements(matrix.LhsSize());
        }
        return false;
      }
    }

    return VerifyMatchMatrix(element_printouts, matrix, listener) &amp;&amp;
           FindPairing(matrix, listener);
  }

 private:
  template &lt;typename ElementIter&gt;
  MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,
                              ::std::vector&lt;std::string&gt;* element_printouts,
                              MatchResultListener* listener) const {
    element_printouts-&gt;clear();
    ::std::vector&lt;char&gt; did_match;
    size_t num_elements = 0;
    DummyMatchResultListener dummy;
    for (; elem_first != elem_last; ++num_elements, ++elem_first) {
      if (listener-&gt;IsInterested()) {
        element_printouts-&gt;push_back(PrintToString(*elem_first));
      }
      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
        did_match.push_back(
            matchers_[irhs].MatchAndExplain(*elem_first, &amp;dummy));
      }
    }

    MatchMatrix matrix(num_elements, matchers_.size());
    ::std::vector&lt;char&gt;::const_iterator did_match_iter = did_match.begin();
    for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {
      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
        matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);
      }
    }
    return matrix;
  }

  ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; matchers_;
};

// Functor for use in TransformTuple.
// Performs MatcherCast&lt;Target&gt; on an input argument of any type.
template &lt;typename Target&gt;
struct CastAndAppendTransform {
  template &lt;typename Arg&gt;
  Matcher&lt;Target&gt; operator()(const Arg&amp; a) const {
    return MatcherCast&lt;Target&gt;(a);
  }
};

// Implements UnorderedElementsAre.
template &lt;typename MatcherTuple&gt;
class UnorderedElementsAreMatcher {
 public:
  explicit UnorderedElementsAreMatcher(const MatcherTuple&amp; args)
      : matchers_(args) {}

  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
    typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;
    typedef typename View::value_type Element;
    typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; MatcherVec;
    MatcherVec matchers;
    matchers.reserve(::std::tuple_size&lt;MatcherTuple&gt;::value);
    TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,
                         ::std::back_inserter(matchers));
    return Matcher&lt;Container&gt;(
        new UnorderedElementsAreMatcherImpl&lt;const Container&amp;&gt;(
            UnorderedMatcherRequire::ExactMatch, matchers.begin(),
            matchers.end()));
  }

 private:
  const MatcherTuple matchers_;
};

// Implements ElementsAre.
template &lt;typename MatcherTuple&gt;
class ElementsAreMatcher {
 public:
  explicit ElementsAreMatcher(const MatcherTuple&amp; args) : matchers_(args) {}

  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    GTEST_COMPILE_ASSERT_(
        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value ||
            ::std::tuple_size&lt;MatcherTuple&gt;::value &lt; 2,
        use_UnorderedElementsAre_with_hash_tables);

    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;
    typedef typename internal::StlContainerView&lt;RawContainer&gt;::type View;
    typedef typename View::value_type Element;
    typedef ::std::vector&lt;Matcher&lt;const Element&amp;&gt; &gt; MatcherVec;
    MatcherVec matchers;
    matchers.reserve(::std::tuple_size&lt;MatcherTuple&gt;::value);
    TransformTupleValues(CastAndAppendTransform&lt;const Element&amp;&gt;(), matchers_,
                         ::std::back_inserter(matchers));
    return Matcher&lt;Container&gt;(new ElementsAreMatcherImpl&lt;const Container&amp;&gt;(
        matchers.begin(), matchers.end()));
  }

 private:
  const MatcherTuple matchers_;
};

// Implements UnorderedElementsAreArray(), IsSubsetOf(), and IsSupersetOf().
template &lt;typename T&gt;
class UnorderedElementsAreArrayMatcher {
 public:
  template &lt;typename Iter&gt;
  UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags match_flags,
                                   Iter first, Iter last)
      : match_flags_(match_flags), matchers_(first, last) {}

  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    return Matcher&lt;Container&gt;(
        new UnorderedElementsAreMatcherImpl&lt;const Container&amp;&gt;(
            match_flags_, matchers_.begin(), matchers_.end()));
  }

 private:
  UnorderedMatcherRequire::Flags match_flags_;
  ::std::vector&lt;T&gt; matchers_;
};

// Implements ElementsAreArray().
template &lt;typename T&gt;
class ElementsAreArrayMatcher {
 public:
  template &lt;typename Iter&gt;
  ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}

  template &lt;typename Container&gt;
  operator Matcher&lt;Container&gt;() const {
    GTEST_COMPILE_ASSERT_(
        !IsHashTable&lt;GTEST_REMOVE_REFERENCE_AND_CONST_(Container)&gt;::value,
        use_UnorderedElementsAreArray_with_hash_tables);

    return Matcher&lt;Container&gt;(new ElementsAreMatcherImpl&lt;const Container&amp;&gt;(
        matchers_.begin(), matchers_.end()));
  }

 private:
  const ::std::vector&lt;T&gt; matchers_;
};

// Given a 2-tuple matcher tm of type Tuple2Matcher and a value second
// of type Second, BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;(tm,
// second) is a polymorphic matcher that matches a value x if and only if
// tm matches tuple (x, second).  Useful for implementing
// UnorderedPointwise() in terms of UnorderedElementsAreArray().
//
// BoundSecondMatcher is copyable and assignable, as we need to put
// instances of this class in a vector when implementing
// UnorderedPointwise().
template &lt;typename Tuple2Matcher, typename Second&gt;
class BoundSecondMatcher {
 public:
  BoundSecondMatcher(const Tuple2Matcher&amp; tm, const Second&amp; second)
      : tuple2_matcher_(tm), second_value_(second) {}

  BoundSecondMatcher(const BoundSecondMatcher&amp; other) = default;

  template &lt;typename T&gt;
  operator Matcher&lt;T&gt;() const {
    return MakeMatcher(new Impl&lt;T&gt;(tuple2_matcher_, second_value_));
  }

  // We have to define this for UnorderedPointwise() to compile in
  // C++98 mode, as it puts BoundSecondMatcher instances in a vector,
  // which requires the elements to be assignable in C++98.  The
  // compiler cannot generate the operator= for us, as Tuple2Matcher
  // and Second may not be assignable.
  //
  // However, this should never be called, so the implementation just
  // need to assert.
  void operator=(const BoundSecondMatcher&amp; /*rhs*/) {
    GTEST_LOG_(FATAL) &lt;&lt; "BoundSecondMatcher should never be assigned.";
  }

 private:
  template &lt;typename T&gt;
  class Impl : public MatcherInterface&lt;T&gt; {
   public:
    typedef ::std::tuple&lt;T, Second&gt; ArgTuple;

    Impl(const Tuple2Matcher&amp; tm, const Second&amp; second)
        : mono_tuple2_matcher_(SafeMatcherCast&lt;const ArgTuple&amp;&gt;(tm)),
          second_value_(second) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "and ";
      UniversalPrint(second_value_, os);
      *os &lt;&lt; " ";
      mono_tuple2_matcher_.DescribeTo(os);
    }

    bool MatchAndExplain(T x, MatchResultListener* listener) const override {
      return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),
                                                  listener);
    }

   private:
    const Matcher&lt;const ArgTuple&amp;&gt; mono_tuple2_matcher_;
    const Second second_value_;
  };

  const Tuple2Matcher tuple2_matcher_;
  const Second second_value_;
};

// Given a 2-tuple matcher tm and a value second,
// MatcherBindSecond(tm, second) returns a matcher that matches a
// value x if and only if tm matches tuple (x, second).  Useful for
// implementing UnorderedPointwise() in terms of UnorderedElementsAreArray().
template &lt;typename Tuple2Matcher, typename Second&gt;
BoundSecondMatcher&lt;Tuple2Matcher, Second&gt; MatcherBindSecond(
    const Tuple2Matcher&amp; tm, const Second&amp; second) {
  return BoundSecondMatcher&lt;Tuple2Matcher, Second&gt;(tm, second);
}

// Returns the description for a matcher defined using the MATCHER*()
// macro where the user-supplied description string is "", if
// 'negation' is false; otherwise returns the description of the
// negation of the matcher.  'param_values' contains a list of strings
// that are the print-out of the matcher's parameters.
GTEST_API_ std::string FormatMatcherDescription(bool negation,
                                                const char* matcher_name,
                                                const Strings&amp; param_values);

// Implements a matcher that checks the value of a optional&lt;&gt; type variable.
template &lt;typename ValueMatcher&gt;
class OptionalMatcher {
 public:
  explicit OptionalMatcher(const ValueMatcher&amp; value_matcher)
      : value_matcher_(value_matcher) {}

  template &lt;typename Optional&gt;
  operator Matcher&lt;Optional&gt;() const {
    return Matcher&lt;Optional&gt;(new Impl&lt;const Optional&amp;&gt;(value_matcher_));
  }

  template &lt;typename Optional&gt;
  class Impl : public MatcherInterface&lt;Optional&gt; {
   public:
    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Optional) OptionalView;
    typedef typename OptionalView::value_type ValueType;
    explicit Impl(const ValueMatcher&amp; value_matcher)
        : value_matcher_(MatcherCast&lt;ValueType&gt;(value_matcher)) {}

    void DescribeTo(::std::ostream* os) const override {
      *os &lt;&lt; "value ";
      value_matcher_.DescribeTo(os);
    }

    void DescribeNegationTo(::std::ostream* os) const override {
      *os &lt;&lt; "value ";
      value_matcher_.DescribeNegationTo(os);
    }

    bool MatchAndExplain(Optional optional,
                         MatchResultListener* listener) const override {
      if (!optional) {
        *listener &lt;&lt; "which is not engaged";
        return false;
      }
      const ValueType&amp; value = *optional;
      StringMatchResultListener value_listener;
      const bool match = value_matcher_.MatchAndExplain(value, &amp;value_listener);
      *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(value)
                &lt;&lt; (match ? " matches" : " doesn't match");
      PrintIfNotEmpty(value_listener.str(), listener-&gt;stream());
      return match;
    }

   private:
    const Matcher&lt;ValueType&gt; value_matcher_;
  };

 private:
  const ValueMatcher value_matcher_;
};

namespace variant_matcher {
// Overloads to allow VariantMatcher to do proper ADL lookup.
template &lt;typename T&gt;
void holds_alternative() {}
template &lt;typename T&gt;
void get() {}

// Implements a matcher that checks the value of a variant&lt;&gt; type variable.
template &lt;typename T&gt;
class VariantMatcher {
 public:
  explicit VariantMatcher(::testing::Matcher&lt;const T&amp;&gt; matcher)
      : matcher_(std::move(matcher)) {}

  template &lt;typename Variant&gt;
  bool MatchAndExplain(const Variant&amp; value,
                       ::testing::MatchResultListener* listener) const {
    using std::get;
    if (!listener-&gt;IsInterested()) {
      return holds_alternative&lt;T&gt;(value) &amp;&amp; matcher_.Matches(get&lt;T&gt;(value));
    }

    if (!holds_alternative&lt;T&gt;(value)) {
      *listener &lt;&lt; "whose value is not of type '" &lt;&lt; GetTypeName() &lt;&lt; "'";
      return false;
    }

    const T&amp; elem = get&lt;T&gt;(value);
    StringMatchResultListener elem_listener;
    const bool match = matcher_.MatchAndExplain(elem, &amp;elem_listener);
    *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(elem)
              &lt;&lt; (match ? " matches" : " doesn't match");
    PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());
    return match;
  }

  void DescribeTo(std::ostream* os) const {
    *os &lt;&lt; "is a variant&lt;&gt; with value of type '" &lt;&lt; GetTypeName()
        &lt;&lt; "' and the value ";
    matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os &lt;&lt; "is a variant&lt;&gt; with value of type other than '" &lt;&lt; GetTypeName()
        &lt;&lt; "' or the value ";
    matcher_.DescribeNegationTo(os);
  }

 private:
  static std::string GetTypeName() {
#if GTEST_HAS_RTTI
    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
        return internal::GetTypeName&lt;T&gt;());
#endif
    return "the element type";
  }

  const ::testing::Matcher&lt;const T&amp;&gt; matcher_;
};

}  // namespace variant_matcher

namespace any_cast_matcher {

// Overloads to allow AnyCastMatcher to do proper ADL lookup.
template &lt;typename T&gt;
void any_cast() {}

// Implements a matcher that any_casts the value.
template &lt;typename T&gt;
class AnyCastMatcher {
 public:
  explicit AnyCastMatcher(const ::testing::Matcher&lt;const T&amp;&gt;&amp; matcher)
      : matcher_(matcher) {}

  template &lt;typename AnyType&gt;
  bool MatchAndExplain(const AnyType&amp; value,
                       ::testing::MatchResultListener* listener) const {
    if (!listener-&gt;IsInterested()) {
      const T* ptr = any_cast&lt;T&gt;(&amp;value);
      return ptr != nullptr &amp;&amp; matcher_.Matches(*ptr);
    }

    const T* elem = any_cast&lt;T&gt;(&amp;value);
    if (elem == nullptr) {
      *listener &lt;&lt; "whose value is not of type '" &lt;&lt; GetTypeName() &lt;&lt; "'";
      return false;
    }

    StringMatchResultListener elem_listener;
    const bool match = matcher_.MatchAndExplain(*elem, &amp;elem_listener);
    *listener &lt;&lt; "whose value " &lt;&lt; PrintToString(*elem)
              &lt;&lt; (match ? " matches" : " doesn't match");
    PrintIfNotEmpty(elem_listener.str(), listener-&gt;stream());
    return match;
  }

  void DescribeTo(std::ostream* os) const {
    *os &lt;&lt; "is an 'any' type with value of type '" &lt;&lt; GetTypeName()
        &lt;&lt; "' and the value ";
    matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os &lt;&lt; "is an 'any' type with value of type other than '" &lt;&lt; GetTypeName()
        &lt;&lt; "' or the value ";
    matcher_.DescribeNegationTo(os);
  }

 private:
  static std::string GetTypeName() {
#if GTEST_HAS_RTTI
    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
        return internal::GetTypeName&lt;T&gt;());
#endif
    return "the element type";
  }

  const ::testing::Matcher&lt;const T&amp;&gt; matcher_;
};

}  // namespace any_cast_matcher

// Implements the Args() matcher.
template &lt;class ArgsTuple, size_t... k&gt;
class ArgsMatcherImpl : public MatcherInterface&lt;ArgsTuple&gt; {
 public:
  using RawArgsTuple = typename std::decay&lt;ArgsTuple&gt;::type;
  using SelectedArgs =
      std::tuple&lt;typename std::tuple_element&lt;k, RawArgsTuple&gt;::type...&gt;;
  using MonomorphicInnerMatcher = Matcher&lt;const SelectedArgs&amp;&gt;;

  template &lt;typename InnerMatcher&gt;
  explicit ArgsMatcherImpl(const InnerMatcher&amp; inner_matcher)
      : inner_matcher_(SafeMatcherCast&lt;const SelectedArgs&amp;&gt;(inner_matcher)) {}

  bool MatchAndExplain(ArgsTuple args,
                       MatchResultListener* listener) const override {
    // Workaround spurious C4100 on MSVC&lt;=15.7 when k is empty.
    (void)args;
    const SelectedArgs&amp; selected_args =
        std::forward_as_tuple(std::get&lt;k&gt;(args)...);
    if (!listener-&gt;IsInterested()) return inner_matcher_.Matches(selected_args);

    PrintIndices(listener-&gt;stream());
    *listener &lt;&lt; "are " &lt;&lt; PrintToString(selected_args);

    StringMatchResultListener inner_listener;
    const bool match =
        inner_matcher_.MatchAndExplain(selected_args, &amp;inner_listener);
    PrintIfNotEmpty(inner_listener.str(), listener-&gt;stream());
    return match;
  }

  void DescribeTo(::std::ostream* os) const override {
    *os &lt;&lt; "are a tuple ";
    PrintIndices(os);
    inner_matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(::std::ostream* os) const override {
    *os &lt;&lt; "are a tuple ";
    PrintIndices(os);
    inner_matcher_.DescribeNegationTo(os);
  }

 private:
  // Prints the indices of the selected fields.
  static void PrintIndices(::std::ostream* os) {
    *os &lt;&lt; "whose fields (";
    const char* sep = "";
    // Workaround spurious C4189 on MSVC&lt;=15.7 when k is empty.
    (void)sep;
    const char* dummy[] = {"", (*os &lt;&lt; sep &lt;&lt; "#" &lt;&lt; k, sep = ", ")...};
    (void)dummy;
    *os &lt;&lt; ") ";
  }

  MonomorphicInnerMatcher inner_matcher_;
};

template &lt;class InnerMatcher, size_t... k&gt;
class ArgsMatcher {
 public:
  explicit ArgsMatcher(InnerMatcher inner_matcher)
      : inner_matcher_(std::move(inner_matcher)) {}

  template &lt;typename ArgsTuple&gt;
  operator Matcher&lt;ArgsTuple&gt;() const {  // NOLINT
    return MakeMatcher(new ArgsMatcherImpl&lt;ArgsTuple, k...&gt;(inner_matcher_));
  }

 private:
  InnerMatcher inner_matcher_;
};

}  // namespace internal

// ElementsAreArray(iterator_first, iterator_last)
// ElementsAreArray(pointer, count)
// ElementsAreArray(array)
// ElementsAreArray(container)
// ElementsAreArray({ e1, e2, ..., en })
//
// The ElementsAreArray() functions are like ElementsAre(...), except
// that they are given a homogeneous sequence rather than taking each
// element as a function argument. The sequence can be specified as an
// array, a pointer and count, a vector, an initializer list, or an
// STL iterator range. In each of these cases, the underlying sequence
// can be either a sequence of values or a sequence of matchers.
//
// All forms of ElementsAreArray() make a copy of the input matcher sequence.

template &lt;typename Iter&gt;
inline internal::ElementsAreArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
ElementsAreArray(Iter first, Iter last) {
  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
  return internal::ElementsAreArrayMatcher&lt;T&gt;(first, last);
}

template &lt;typename T&gt;
inline internal::ElementsAreArrayMatcher&lt;T&gt; ElementsAreArray(
    const T* pointer, size_t count) {
  return ElementsAreArray(pointer, pointer + count);
}

template &lt;typename T, size_t N&gt;
inline internal::ElementsAreArrayMatcher&lt;T&gt; ElementsAreArray(
    const T (&amp;array)[N]) {
  return ElementsAreArray(array, N);
}

template &lt;typename Container&gt;
inline internal::ElementsAreArrayMatcher&lt;typename Container::value_type&gt;
ElementsAreArray(const Container&amp; container) {
  return ElementsAreArray(container.begin(), container.end());
}

template &lt;typename T&gt;
inline internal::ElementsAreArrayMatcher&lt;T&gt;
ElementsAreArray(::std::initializer_list&lt;T&gt; xs) {
  return ElementsAreArray(xs.begin(), xs.end());
}

// UnorderedElementsAreArray(iterator_first, iterator_last)
// UnorderedElementsAreArray(pointer, count)
// UnorderedElementsAreArray(array)
// UnorderedElementsAreArray(container)
// UnorderedElementsAreArray({ e1, e2, ..., en })
//
// UnorderedElementsAreArray() verifies that a bijective mapping onto a
// collection of matchers exists.
//
// The matchers can be specified as an array, a pointer and count, a container,
// an initializer list, or an STL iterator range. In each of these cases, the
// underlying matchers can be either values or matchers.

template &lt;typename Iter&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
UnorderedElementsAreArray(Iter first, Iter last) {
  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
      internal::UnorderedMatcherRequire::ExactMatch, first, last);
}

template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
UnorderedElementsAreArray(const T* pointer, size_t count) {
  return UnorderedElementsAreArray(pointer, pointer + count);
}

template &lt;typename T, size_t N&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
UnorderedElementsAreArray(const T (&amp;array)[N]) {
  return UnorderedElementsAreArray(array, N);
}

template &lt;typename Container&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename Container::value_type&gt;
UnorderedElementsAreArray(const Container&amp; container) {
  return UnorderedElementsAreArray(container.begin(), container.end());
}

template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt;
UnorderedElementsAreArray(::std::initializer_list&lt;T&gt; xs) {
  return UnorderedElementsAreArray(xs.begin(), xs.end());
}

// _ is a matcher that matches anything of any type.
//
// This definition is fine as:
//
//   1. The C++ standard permits using the name _ in a namespace that
//      is not the global namespace or ::std.
//   2. The AnythingMatcher class has no data member or constructor,
//      so it's OK to create global variables of this type.
//   3. c-style has approved of using _ in this case.
const internal::AnythingMatcher _ = {};
// Creates a matcher that matches any value of the given type T.
template &lt;typename T&gt;
inline Matcher&lt;T&gt; A() {
  return _;
}

// Creates a matcher that matches any value of the given type T.
template &lt;typename T&gt;
inline Matcher&lt;T&gt; An() {
  return _;
}

template &lt;typename T, typename M&gt;
Matcher&lt;T&gt; internal::MatcherCastImpl&lt;T, M&gt;::CastImpl(
    const M&amp; value, std::false_type /* convertible_to_matcher */,
    std::false_type /* convertible_to_T */) {
  return Eq(value);
}

// Creates a polymorphic matcher that matches any NULL pointer.
inline PolymorphicMatcher&lt;internal::IsNullMatcher &gt; IsNull() {
  return MakePolymorphicMatcher(internal::IsNullMatcher());
}

// Creates a polymorphic matcher that matches any non-NULL pointer.
// This is convenient as Not(NULL) doesn't compile (the compiler
// thinks that that expression is comparing a pointer with an integer).
inline PolymorphicMatcher&lt;internal::NotNullMatcher &gt; NotNull() {
  return MakePolymorphicMatcher(internal::NotNullMatcher());
}

// Creates a polymorphic matcher that matches any argument that
// references variable x.
template &lt;typename T&gt;
inline internal::RefMatcher&lt;T&amp;&gt; Ref(T&amp; x) {  // NOLINT
  return internal::RefMatcher&lt;T&amp;&gt;(x);
}

// Creates a polymorphic matcher that matches any NaN floating point.
inline PolymorphicMatcher&lt;internal::IsNanMatcher&gt; IsNan() {
  return MakePolymorphicMatcher(internal::IsNanMatcher());
}

// Creates a matcher that matches any double argument approximately
// equal to rhs, where two NANs are considered unequal.
inline internal::FloatingEqMatcher&lt;double&gt; DoubleEq(double rhs) {
  return internal::FloatingEqMatcher&lt;double&gt;(rhs, false);
}

// Creates a matcher that matches any double argument approximately
// equal to rhs, including NaN values when rhs is NaN.
inline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleEq(double rhs) {
  return internal::FloatingEqMatcher&lt;double&gt;(rhs, true);
}

// Creates a matcher that matches any double argument approximately equal to
// rhs, up to the specified max absolute error bound, where two NANs are
// considered unequal.  The max absolute error bound must be non-negative.
inline internal::FloatingEqMatcher&lt;double&gt; DoubleNear(
    double rhs, double max_abs_error) {
  return internal::FloatingEqMatcher&lt;double&gt;(rhs, false, max_abs_error);
}

// Creates a matcher that matches any double argument approximately equal to
// rhs, up to the specified max absolute error bound, including NaN values when
// rhs is NaN.  The max absolute error bound must be non-negative.
inline internal::FloatingEqMatcher&lt;double&gt; NanSensitiveDoubleNear(
    double rhs, double max_abs_error) {
  return internal::FloatingEqMatcher&lt;double&gt;(rhs, true, max_abs_error);
}

// Creates a matcher that matches any float argument approximately
// equal to rhs, where two NANs are considered unequal.
inline internal::FloatingEqMatcher&lt;float&gt; FloatEq(float rhs) {
  return internal::FloatingEqMatcher&lt;float&gt;(rhs, false);
}

// Creates a matcher that matches any float argument approximately
// equal to rhs, including NaN values when rhs is NaN.
inline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatEq(float rhs) {
  return internal::FloatingEqMatcher&lt;float&gt;(rhs, true);
}

// Creates a matcher that matches any float argument approximately equal to
// rhs, up to the specified max absolute error bound, where two NANs are
// considered unequal.  The max absolute error bound must be non-negative.
inline internal::FloatingEqMatcher&lt;float&gt; FloatNear(
    float rhs, float max_abs_error) {
  return internal::FloatingEqMatcher&lt;float&gt;(rhs, false, max_abs_error);
}

// Creates a matcher that matches any float argument approximately equal to
// rhs, up to the specified max absolute error bound, including NaN values when
// rhs is NaN.  The max absolute error bound must be non-negative.
inline internal::FloatingEqMatcher&lt;float&gt; NanSensitiveFloatNear(
    float rhs, float max_abs_error) {
  return internal::FloatingEqMatcher&lt;float&gt;(rhs, true, max_abs_error);
}

// Creates a matcher that matches a pointer (raw or smart) that points
// to a value that matches inner_matcher.
template &lt;typename InnerMatcher&gt;
inline internal::PointeeMatcher&lt;InnerMatcher&gt; Pointee(
    const InnerMatcher&amp; inner_matcher) {
  return internal::PointeeMatcher&lt;InnerMatcher&gt;(inner_matcher);
}

#if GTEST_HAS_RTTI
// Creates a matcher that matches a pointer or reference that matches
// inner_matcher when dynamic_cast&lt;To&gt; is applied.
// The result of dynamic_cast&lt;To&gt; is forwarded to the inner matcher.
// If To is a pointer and the cast fails, the inner matcher will receive NULL.
// If To is a reference and the cast fails, this matcher returns false
// immediately.
template &lt;typename To&gt;
inline PolymorphicMatcher&lt;internal::WhenDynamicCastToMatcher&lt;To&gt; &gt;
WhenDynamicCastTo(const Matcher&lt;To&gt;&amp; inner_matcher) {
  return MakePolymorphicMatcher(
      internal::WhenDynamicCastToMatcher&lt;To&gt;(inner_matcher));
}
#endif  // GTEST_HAS_RTTI

// Creates a matcher that matches an object whose given field matches
// 'matcher'.  For example,
//   Field(&amp;Foo::number, Ge(5))
// matches a Foo object x if and only if x.number &gt;= 5.
template &lt;typename Class, typename FieldType, typename FieldMatcher&gt;
inline PolymorphicMatcher&lt;
  internal::FieldMatcher&lt;Class, FieldType&gt; &gt; Field(
    FieldType Class::*field, const FieldMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::FieldMatcher&lt;Class, FieldType&gt;(
          field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));
  // The call to MatcherCast() is required for supporting inner
  // matchers of compatible types.  For example, it allows
  //   Field(&amp;Foo::bar, m)
  // to compile where bar is an int32 and m is a matcher for int64.
}

// Same as Field() but also takes the name of the field to provide better error
// messages.
template &lt;typename Class, typename FieldType, typename FieldMatcher&gt;
inline PolymorphicMatcher&lt;internal::FieldMatcher&lt;Class, FieldType&gt; &gt; Field(
    const std::string&amp; field_name, FieldType Class::*field,
    const FieldMatcher&amp; matcher) {
  return MakePolymorphicMatcher(internal::FieldMatcher&lt;Class, FieldType&gt;(
      field_name, field, MatcherCast&lt;const FieldType&amp;&gt;(matcher)));
}

// Creates a matcher that matches an object whose given property
// matches 'matcher'.  For example,
//   Property(&amp;Foo::str, StartsWith("hi"))
// matches a Foo object x if and only if x.str() starts with "hi".
template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
    Class, PropertyType, PropertyType (Class::*)() const&gt; &gt;
Property(PropertyType (Class::*property)() const,
         const PropertyMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::PropertyMatcher&lt;Class, PropertyType,
                                PropertyType (Class::*)() const&gt;(
          property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
  // The call to MatcherCast() is required for supporting inner
  // matchers of compatible types.  For example, it allows
  //   Property(&amp;Foo::bar, m)
  // to compile where bar() returns an int32 and m is a matcher for int64.
}

// Same as Property() above, but also takes the name of the property to provide
// better error messages.
template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
    Class, PropertyType, PropertyType (Class::*)() const&gt; &gt;
Property(const std::string&amp; property_name,
         PropertyType (Class::*property)() const,
         const PropertyMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::PropertyMatcher&lt;Class, PropertyType,
                                PropertyType (Class::*)() const&gt;(
          property_name, property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
}

// The same as above but for reference-qualified member functions.
template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
    Class, PropertyType, PropertyType (Class::*)() const &amp;&gt; &gt;
Property(PropertyType (Class::*property)() const &amp;,
         const PropertyMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::PropertyMatcher&lt;Class, PropertyType,
                                PropertyType (Class::*)() const&amp;&gt;(
          property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
}

// Three-argument form for reference-qualified member functions.
template &lt;typename Class, typename PropertyType, typename PropertyMatcher&gt;
inline PolymorphicMatcher&lt;internal::PropertyMatcher&lt;
    Class, PropertyType, PropertyType (Class::*)() const &amp;&gt; &gt;
Property(const std::string&amp; property_name,
         PropertyType (Class::*property)() const &amp;,
         const PropertyMatcher&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::PropertyMatcher&lt;Class, PropertyType,
                                PropertyType (Class::*)() const&amp;&gt;(
          property_name, property, MatcherCast&lt;const PropertyType&amp;&gt;(matcher)));
}

// Creates a matcher that matches an object if and only if the result of
// applying a callable to x matches 'matcher'. For example,
//   ResultOf(f, StartsWith("hi"))
// matches a Foo object x if and only if f(x) starts with "hi".
// `callable` parameter can be a function, function pointer, or a functor. It is
// required to keep no state affecting the results of the calls on it and make
// no assumptions about how many calls will be made. Any state it keeps must be
// protected from the concurrent access.
template &lt;typename Callable, typename InnerMatcher&gt;
internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt; ResultOf(
    Callable callable, InnerMatcher matcher) {
  return internal::ResultOfMatcher&lt;Callable, InnerMatcher&gt;(
      std::move(callable), std::move(matcher));
}

// String matchers.

// Matches a string equal to str.
template &lt;typename T = std::string&gt;
PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrEq(
    const internal::StringLike&lt;T&gt;&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::string&gt;(std::string(str), true, true));
}

// Matches a string not equal to str.
template &lt;typename T = std::string&gt;
PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrNe(
    const internal::StringLike&lt;T&gt;&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::string&gt;(std::string(str), false, true));
}

// Matches a string equal to str, ignoring case.
template &lt;typename T = std::string&gt;
PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrCaseEq(
    const internal::StringLike&lt;T&gt;&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::string&gt;(std::string(str), true, false));
}

// Matches a string not equal to str, ignoring case.
template &lt;typename T = std::string&gt;
PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::string&gt; &gt; StrCaseNe(
    const internal::StringLike&lt;T&gt;&amp; str) {
  return MakePolymorphicMatcher(internal::StrEqualityMatcher&lt;std::string&gt;(
      std::string(str), false, false));
}

// Creates a matcher that matches any string, std::string, or C string
// that contains the given substring.
template &lt;typename T = std::string&gt;
PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::string&gt; &gt; HasSubstr(
    const internal::StringLike&lt;T&gt;&amp; substring) {
  return MakePolymorphicMatcher(
      internal::HasSubstrMatcher&lt;std::string&gt;(std::string(substring)));
}

// Matches a string that starts with 'prefix' (case-sensitive).
template &lt;typename T = std::string&gt;
PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::string&gt; &gt; StartsWith(
    const internal::StringLike&lt;T&gt;&amp; prefix) {
  return MakePolymorphicMatcher(
      internal::StartsWithMatcher&lt;std::string&gt;(std::string(prefix)));
}

// Matches a string that ends with 'suffix' (case-sensitive).
template &lt;typename T = std::string&gt;
PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::string&gt; &gt; EndsWith(
    const internal::StringLike&lt;T&gt;&amp; suffix) {
  return MakePolymorphicMatcher(
      internal::EndsWithMatcher&lt;std::string&gt;(std::string(suffix)));
}

#if GTEST_HAS_STD_WSTRING
// Wide string matchers.

// Matches a string equal to str.
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt; StrEq(
    const std::wstring&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, true));
}

// Matches a string not equal to str.
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt; StrNe(
    const std::wstring&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, true));
}

// Matches a string equal to str, ignoring case.
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt;
StrCaseEq(const std::wstring&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, true, false));
}

// Matches a string not equal to str, ignoring case.
inline PolymorphicMatcher&lt;internal::StrEqualityMatcher&lt;std::wstring&gt; &gt;
StrCaseNe(const std::wstring&amp; str) {
  return MakePolymorphicMatcher(
      internal::StrEqualityMatcher&lt;std::wstring&gt;(str, false, false));
}

// Creates a matcher that matches any ::wstring, std::wstring, or C wide string
// that contains the given substring.
inline PolymorphicMatcher&lt;internal::HasSubstrMatcher&lt;std::wstring&gt; &gt; HasSubstr(
    const std::wstring&amp; substring) {
  return MakePolymorphicMatcher(
      internal::HasSubstrMatcher&lt;std::wstring&gt;(substring));
}

// Matches a string that starts with 'prefix' (case-sensitive).
inline PolymorphicMatcher&lt;internal::StartsWithMatcher&lt;std::wstring&gt; &gt;
StartsWith(const std::wstring&amp; prefix) {
  return MakePolymorphicMatcher(
      internal::StartsWithMatcher&lt;std::wstring&gt;(prefix));
}

// Matches a string that ends with 'suffix' (case-sensitive).
inline PolymorphicMatcher&lt;internal::EndsWithMatcher&lt;std::wstring&gt; &gt; EndsWith(
    const std::wstring&amp; suffix) {
  return MakePolymorphicMatcher(
      internal::EndsWithMatcher&lt;std::wstring&gt;(suffix));
}

#endif  // GTEST_HAS_STD_WSTRING

// Creates a polymorphic matcher that matches a 2-tuple where the
// first field == the second field.
inline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }

// Creates a polymorphic matcher that matches a 2-tuple where the
// first field &gt;= the second field.
inline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }

// Creates a polymorphic matcher that matches a 2-tuple where the
// first field &gt; the second field.
inline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }

// Creates a polymorphic matcher that matches a 2-tuple where the
// first field &lt;= the second field.
inline internal::Le2Matcher Le() { return internal::Le2Matcher(); }

// Creates a polymorphic matcher that matches a 2-tuple where the
// first field &lt; the second field.
inline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }

// Creates a polymorphic matcher that matches a 2-tuple where the
// first field != the second field.
inline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }

// Creates a polymorphic matcher that matches a 2-tuple where
// FloatEq(first field) matches the second field.
inline internal::FloatingEq2Matcher&lt;float&gt; FloatEq() {
  return internal::FloatingEq2Matcher&lt;float&gt;();
}

// Creates a polymorphic matcher that matches a 2-tuple where
// DoubleEq(first field) matches the second field.
inline internal::FloatingEq2Matcher&lt;double&gt; DoubleEq() {
  return internal::FloatingEq2Matcher&lt;double&gt;();
}

// Creates a polymorphic matcher that matches a 2-tuple where
// FloatEq(first field) matches the second field with NaN equality.
inline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatEq() {
  return internal::FloatingEq2Matcher&lt;float&gt;(true);
}

// Creates a polymorphic matcher that matches a 2-tuple where
// DoubleEq(first field) matches the second field with NaN equality.
inline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleEq() {
  return internal::FloatingEq2Matcher&lt;double&gt;(true);
}

// Creates a polymorphic matcher that matches a 2-tuple where
// FloatNear(first field, max_abs_error) matches the second field.
inline internal::FloatingEq2Matcher&lt;float&gt; FloatNear(float max_abs_error) {
  return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error);
}

// Creates a polymorphic matcher that matches a 2-tuple where
// DoubleNear(first field, max_abs_error) matches the second field.
inline internal::FloatingEq2Matcher&lt;double&gt; DoubleNear(double max_abs_error) {
  return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error);
}

// Creates a polymorphic matcher that matches a 2-tuple where
// FloatNear(first field, max_abs_error) matches the second field with NaN
// equality.
inline internal::FloatingEq2Matcher&lt;float&gt; NanSensitiveFloatNear(
    float max_abs_error) {
  return internal::FloatingEq2Matcher&lt;float&gt;(max_abs_error, true);
}

// Creates a polymorphic matcher that matches a 2-tuple where
// DoubleNear(first field, max_abs_error) matches the second field with NaN
// equality.
inline internal::FloatingEq2Matcher&lt;double&gt; NanSensitiveDoubleNear(
    double max_abs_error) {
  return internal::FloatingEq2Matcher&lt;double&gt;(max_abs_error, true);
}

// Creates a matcher that matches any value of type T that m doesn't
// match.
template &lt;typename InnerMatcher&gt;
inline internal::NotMatcher&lt;InnerMatcher&gt; Not(InnerMatcher m) {
  return internal::NotMatcher&lt;InnerMatcher&gt;(m);
}

// Returns a matcher that matches anything that satisfies the given
// predicate.  The predicate can be any unary function or functor
// whose return type can be implicitly converted to bool.
template &lt;typename Predicate&gt;
inline PolymorphicMatcher&lt;internal::TrulyMatcher&lt;Predicate&gt; &gt;
Truly(Predicate pred) {
  return MakePolymorphicMatcher(internal::TrulyMatcher&lt;Predicate&gt;(pred));
}

// Returns a matcher that matches the container size. The container must
// support both size() and size_type which all STL-like containers provide.
// Note that the parameter 'size' can be a value of type size_type as well as
// matcher. For instance:
//   EXPECT_THAT(container, SizeIs(2));     // Checks container has 2 elements.
//   EXPECT_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.
template &lt;typename SizeMatcher&gt;
inline internal::SizeIsMatcher&lt;SizeMatcher&gt;
SizeIs(const SizeMatcher&amp; size_matcher) {
  return internal::SizeIsMatcher&lt;SizeMatcher&gt;(size_matcher);
}

// Returns a matcher that matches the distance between the container's begin()
// iterator and its end() iterator, i.e. the size of the container. This matcher
// can be used instead of SizeIs with containers such as std::forward_list which
// do not implement size(). The container must provide const_iterator (with
// valid iterator_traits), begin() and end().
template &lt;typename DistanceMatcher&gt;
inline internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;
BeginEndDistanceIs(const DistanceMatcher&amp; distance_matcher) {
  return internal::BeginEndDistanceIsMatcher&lt;DistanceMatcher&gt;(distance_matcher);
}

// Returns a matcher that matches an equal container.
// This matcher behaves like Eq(), but in the event of mismatch lists the
// values that are included in one container but not the other. (Duplicate
// values and order differences are not explained.)
template &lt;typename Container&gt;
inline PolymorphicMatcher&lt;internal::ContainerEqMatcher&lt;
    typename std::remove_const&lt;Container&gt;::type&gt;&gt;
ContainerEq(const Container&amp; rhs) {
  return MakePolymorphicMatcher(internal::ContainerEqMatcher&lt;Container&gt;(rhs));
}

// Returns a matcher that matches a container that, when sorted using
// the given comparator, matches container_matcher.
template &lt;typename Comparator, typename ContainerMatcher&gt;
inline internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;
WhenSortedBy(const Comparator&amp; comparator,
             const ContainerMatcher&amp; container_matcher) {
  return internal::WhenSortedByMatcher&lt;Comparator, ContainerMatcher&gt;(
      comparator, container_matcher);
}

// Returns a matcher that matches a container that, when sorted using
// the &lt; operator, matches container_matcher.
template &lt;typename ContainerMatcher&gt;
inline internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;
WhenSorted(const ContainerMatcher&amp; container_matcher) {
  return
      internal::WhenSortedByMatcher&lt;internal::LessComparator, ContainerMatcher&gt;(
          internal::LessComparator(), container_matcher);
}

// Matches an STL-style container or a native array that contains the
// same number of elements as in rhs, where its i-th element and rhs's
// i-th element (as a pair) satisfy the given pair matcher, for all i.
// TupleMatcher must be able to be safely cast to Matcher&lt;std::tuple&lt;const
// T1&amp;, const T2&amp;&gt; &gt;, where T1 and T2 are the types of elements in the
// LHS container and the RHS container respectively.
template &lt;typename TupleMatcher, typename Container&gt;
inline internal::PointwiseMatcher&lt;TupleMatcher,
                                  typename std::remove_const&lt;Container&gt;::type&gt;
Pointwise(const TupleMatcher&amp; tuple_matcher, const Container&amp; rhs) {
  return internal::PointwiseMatcher&lt;TupleMatcher, Container&gt;(tuple_matcher,
                                                             rhs);
}


// Supports the Pointwise(m, {a, b, c}) syntax.
template &lt;typename TupleMatcher, typename T&gt;
inline internal::PointwiseMatcher&lt;TupleMatcher, std::vector&lt;T&gt; &gt; Pointwise(
    const TupleMatcher&amp; tuple_matcher, std::initializer_list&lt;T&gt; rhs) {
  return Pointwise(tuple_matcher, std::vector&lt;T&gt;(rhs));
}


// UnorderedPointwise(pair_matcher, rhs) matches an STL-style
// container or a native array that contains the same number of
// elements as in rhs, where in some permutation of the container, its
// i-th element and rhs's i-th element (as a pair) satisfy the given
// pair matcher, for all i.  Tuple2Matcher must be able to be safely
// cast to Matcher&lt;std::tuple&lt;const T1&amp;, const T2&amp;&gt; &gt;, where T1 and T2 are
// the types of elements in the LHS container and the RHS container
// respectively.
//
// This is like Pointwise(pair_matcher, rhs), except that the element
// order doesn't matter.
template &lt;typename Tuple2Matcher, typename RhsContainer&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename internal::BoundSecondMatcher&lt;
        Tuple2Matcher,
        typename internal::StlContainerView&lt;
            typename std::remove_const&lt;RhsContainer&gt;::type&gt;::type::value_type&gt;&gt;
UnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,
                   const RhsContainer&amp; rhs_container) {
  // RhsView allows the same code to handle RhsContainer being a
  // STL-style container and it being a native C-style array.
  typedef typename internal::StlContainerView&lt;RhsContainer&gt; RhsView;
  typedef typename RhsView::type RhsStlContainer;
  typedef typename RhsStlContainer::value_type Second;
  const RhsStlContainer&amp; rhs_stl_container =
      RhsView::ConstReference(rhs_container);

  // Create a matcher for each element in rhs_container.
  ::std::vector&lt;internal::BoundSecondMatcher&lt;Tuple2Matcher, Second&gt; &gt; matchers;
  for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();
       it != rhs_stl_container.end(); ++it) {
    matchers.push_back(
        internal::MatcherBindSecond(tuple2_matcher, *it));
  }

  // Delegate the work to UnorderedElementsAreArray().
  return UnorderedElementsAreArray(matchers);
}


// Supports the UnorderedPointwise(m, {a, b, c}) syntax.
template &lt;typename Tuple2Matcher, typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename internal::BoundSecondMatcher&lt;Tuple2Matcher, T&gt; &gt;
UnorderedPointwise(const Tuple2Matcher&amp; tuple2_matcher,
                   std::initializer_list&lt;T&gt; rhs) {
  return UnorderedPointwise(tuple2_matcher, std::vector&lt;T&gt;(rhs));
}


// Matches an STL-style container or a native array that contains at
// least one element matching the given value or matcher.
//
// Examples:
//   ::std::set&lt;int&gt; page_ids;
//   page_ids.insert(3);
//   page_ids.insert(1);
//   EXPECT_THAT(page_ids, Contains(1));
//   EXPECT_THAT(page_ids, Contains(Gt(2)));
//   EXPECT_THAT(page_ids, Not(Contains(4)));
//
//   ::std::map&lt;int, size_t&gt; page_lengths;
//   page_lengths[1] = 100;
//   EXPECT_THAT(page_lengths,
//               Contains(::std::pair&lt;const int, size_t&gt;(1, 100)));
//
//   const char* user_ids[] = { "joe", "mike", "tom" };
//   EXPECT_THAT(user_ids, Contains(Eq(::std::string("tom"))));
template &lt;typename M&gt;
inline internal::ContainsMatcher&lt;M&gt; Contains(M matcher) {
  return internal::ContainsMatcher&lt;M&gt;(matcher);
}

// IsSupersetOf(iterator_first, iterator_last)
// IsSupersetOf(pointer, count)
// IsSupersetOf(array)
// IsSupersetOf(container)
// IsSupersetOf({e1, e2, ..., en})
//
// IsSupersetOf() verifies that a surjective partial mapping onto a collection
// of matchers exists. In other words, a container matches
// IsSupersetOf({e1, ..., en}) if and only if there is a permutation
// {y1, ..., yn} of some of the container's elements where y1 matches e1,
// ..., and yn matches en. Obviously, the size of the container must be &gt;= n
// in order to have a match. Examples:
//
// - {1, 2, 3} matches IsSupersetOf({Ge(3), Ne(0)}), as 3 matches Ge(3) and
//   1 matches Ne(0).
// - {1, 2} doesn't match IsSupersetOf({Eq(1), Lt(2)}), even though 1 matches
//   both Eq(1) and Lt(2). The reason is that different matchers must be used
//   for elements in different slots of the container.
// - {1, 1, 2} matches IsSupersetOf({Eq(1), Lt(2)}), as (the first) 1 matches
//   Eq(1) and (the second) 1 matches Lt(2).
// - {1, 2, 3} matches IsSupersetOf(Gt(1), Gt(1)), as 2 matches (the first)
//   Gt(1) and 3 matches (the second) Gt(1).
//
// The matchers can be specified as an array, a pointer and count, a container,
// an initializer list, or an STL iterator range. In each of these cases, the
// underlying matchers can be either values or matchers.

template &lt;typename Iter&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
IsSupersetOf(Iter first, Iter last) {
  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
      internal::UnorderedMatcherRequire::Superset, first, last);
}

template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
    const T* pointer, size_t count) {
  return IsSupersetOf(pointer, pointer + count);
}

template &lt;typename T, size_t N&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
    const T (&amp;array)[N]) {
  return IsSupersetOf(array, N);
}

template &lt;typename Container&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename Container::value_type&gt;
IsSupersetOf(const Container&amp; container) {
  return IsSupersetOf(container.begin(), container.end());
}

template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSupersetOf(
    ::std::initializer_list&lt;T&gt; xs) {
  return IsSupersetOf(xs.begin(), xs.end());
}

// IsSubsetOf(iterator_first, iterator_last)
// IsSubsetOf(pointer, count)
// IsSubsetOf(array)
// IsSubsetOf(container)
// IsSubsetOf({e1, e2, ..., en})
//
// IsSubsetOf() verifies that an injective mapping onto a collection of matchers
// exists.  In other words, a container matches IsSubsetOf({e1, ..., en}) if and
// only if there is a subset of matchers {m1, ..., mk} which would match the
// container using UnorderedElementsAre.  Obviously, the size of the container
// must be &lt;= n in order to have a match. Examples:
//
// - {1} matches IsSubsetOf({Gt(0), Lt(0)}), as 1 matches Gt(0).
// - {1, -1} matches IsSubsetOf({Lt(0), Gt(0)}), as 1 matches Gt(0) and -1
//   matches Lt(0).
// - {1, 2} doesn't matches IsSubsetOf({Gt(0), Lt(0)}), even though 1 and 2 both
//   match Gt(0). The reason is that different matchers must be used for
//   elements in different slots of the container.
//
// The matchers can be specified as an array, a pointer and count, a container,
// an initializer list, or an STL iterator range. In each of these cases, the
// underlying matchers can be either values or matchers.

template &lt;typename Iter&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
IsSubsetOf(Iter first, Iter last) {
  typedef typename ::std::iterator_traits&lt;Iter&gt;::value_type T;
  return internal::UnorderedElementsAreArrayMatcher&lt;T&gt;(
      internal::UnorderedMatcherRequire::Subset, first, last);
}

template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
    const T* pointer, size_t count) {
  return IsSubsetOf(pointer, pointer + count);
}

template &lt;typename T, size_t N&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
    const T (&amp;array)[N]) {
  return IsSubsetOf(array, N);
}

template &lt;typename Container&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;
    typename Container::value_type&gt;
IsSubsetOf(const Container&amp; container) {
  return IsSubsetOf(container.begin(), container.end());
}

template &lt;typename T&gt;
inline internal::UnorderedElementsAreArrayMatcher&lt;T&gt; IsSubsetOf(
    ::std::initializer_list&lt;T&gt; xs) {
  return IsSubsetOf(xs.begin(), xs.end());
}

// Matches an STL-style container or a native array that contains only
// elements matching the given value or matcher.
//
// Each(m) is semantically equivalent to Not(Contains(Not(m))). Only
// the messages are different.
//
// Examples:
//   ::std::set&lt;int&gt; page_ids;
//   // Each(m) matches an empty container, regardless of what m is.
//   EXPECT_THAT(page_ids, Each(Eq(1)));
//   EXPECT_THAT(page_ids, Each(Eq(77)));
//
//   page_ids.insert(3);
//   EXPECT_THAT(page_ids, Each(Gt(0)));
//   EXPECT_THAT(page_ids, Not(Each(Gt(4))));
//   page_ids.insert(1);
//   EXPECT_THAT(page_ids, Not(Each(Lt(2))));
//
//   ::std::map&lt;int, size_t&gt; page_lengths;
//   page_lengths[1] = 100;
//   page_lengths[2] = 200;
//   page_lengths[3] = 300;
//   EXPECT_THAT(page_lengths, Not(Each(Pair(1, 100))));
//   EXPECT_THAT(page_lengths, Each(Key(Le(3))));
//
//   const char* user_ids[] = { "joe", "mike", "tom" };
//   EXPECT_THAT(user_ids, Not(Each(Eq(::std::string("tom")))));
template &lt;typename M&gt;
inline internal::EachMatcher&lt;M&gt; Each(M matcher) {
  return internal::EachMatcher&lt;M&gt;(matcher);
}

// Key(inner_matcher) matches an std::pair whose 'first' field matches
// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an
// std::map that contains at least one element whose key is &gt;= 5.
template &lt;typename M&gt;
inline internal::KeyMatcher&lt;M&gt; Key(M inner_matcher) {
  return internal::KeyMatcher&lt;M&gt;(inner_matcher);
}

// Pair(first_matcher, second_matcher) matches a std::pair whose 'first' field
// matches first_matcher and whose 'second' field matches second_matcher.  For
// example, EXPECT_THAT(map_type, ElementsAre(Pair(Ge(5), "foo"))) can be used
// to match a std::map&lt;int, string&gt; that contains exactly one element whose key
// is &gt;= 5 and whose value equals "foo".
template &lt;typename FirstMatcher, typename SecondMatcher&gt;
inline internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;
Pair(FirstMatcher first_matcher, SecondMatcher second_matcher) {
  return internal::PairMatcher&lt;FirstMatcher, SecondMatcher&gt;(
      first_matcher, second_matcher);
}

namespace no_adl {
// FieldsAre(matchers...) matches piecewise the fields of compatible structs.
// These include those that support `get&lt;I&gt;(obj)`, and when structured bindings
// are enabled any class that supports them.
// In particular, `std::tuple`, `std::pair`, `std::array` and aggregate types.
template &lt;typename... M&gt;
internal::FieldsAreMatcher&lt;typename std::decay&lt;M&gt;::type...&gt; FieldsAre(
    M&amp;&amp;... matchers) {
  return internal::FieldsAreMatcher&lt;typename std::decay&lt;M&gt;::type...&gt;(
      std::forward&lt;M&gt;(matchers)...);
}

// Creates a matcher that matches a pointer (raw or smart) that matches
// inner_matcher.
template &lt;typename InnerMatcher&gt;
inline internal::PointerMatcher&lt;InnerMatcher&gt; Pointer(
    const InnerMatcher&amp; inner_matcher) {
  return internal::PointerMatcher&lt;InnerMatcher&gt;(inner_matcher);
}

// Creates a matcher that matches an object that has an address that matches
// inner_matcher.
template &lt;typename InnerMatcher&gt;
inline internal::AddressMatcher&lt;InnerMatcher&gt; Address(
    const InnerMatcher&amp; inner_matcher) {
  return internal::AddressMatcher&lt;InnerMatcher&gt;(inner_matcher);
}
}  // namespace no_adl

// Returns a predicate that is satisfied by anything that matches the
// given matcher.
template &lt;typename M&gt;
inline internal::MatcherAsPredicate&lt;M&gt; Matches(M matcher) {
  return internal::MatcherAsPredicate&lt;M&gt;(matcher);
}

// Returns true if and only if the value matches the matcher.
template &lt;typename T, typename M&gt;
inline bool Value(const T&amp; value, M matcher) {
  return testing::Matches(matcher)(value);
}

// Matches the value against the given matcher and explains the match
// result to listener.
template &lt;typename T, typename M&gt;
inline bool ExplainMatchResult(
    M matcher, const T&amp; value, MatchResultListener* listener) {
  return SafeMatcherCast&lt;const T&amp;&gt;(matcher).MatchAndExplain(value, listener);
}

// Returns a string representation of the given matcher.  Useful for description
// strings of matchers defined using MATCHER_P* macros that accept matchers as
// their arguments.  For example:
//
// MATCHER_P(XAndYThat, matcher,
//           "X that " + DescribeMatcher&lt;int&gt;(matcher, negation) +
//               " and Y that " + DescribeMatcher&lt;double&gt;(matcher, negation)) {
//   return ExplainMatchResult(matcher, arg.x(), result_listener) &amp;&amp;
//          ExplainMatchResult(matcher, arg.y(), result_listener);
// }
template &lt;typename T, typename M&gt;
std::string DescribeMatcher(const M&amp; matcher, bool negation = false) {
  ::std::stringstream ss;
  Matcher&lt;T&gt; monomorphic_matcher = SafeMatcherCast&lt;T&gt;(matcher);
  if (negation) {
    monomorphic_matcher.DescribeNegationTo(&amp;ss);
  } else {
    monomorphic_matcher.DescribeTo(&amp;ss);
  }
  return ss.str();
}

template &lt;typename... Args&gt;
internal::ElementsAreMatcher&lt;
    std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;
ElementsAre(const Args&amp;... matchers) {
  return internal::ElementsAreMatcher&lt;
      std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(
      std::make_tuple(matchers...));
}

template &lt;typename... Args&gt;
internal::UnorderedElementsAreMatcher&lt;
    std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;
UnorderedElementsAre(const Args&amp;... matchers) {
  return internal::UnorderedElementsAreMatcher&lt;
      std::tuple&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;&gt;(
      std::make_tuple(matchers...));
}

// Define variadic matcher versions.
template &lt;typename... Args&gt;
internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AllOf(
    const Args&amp;... matchers) {
  return internal::AllOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(
      matchers...);
}

template &lt;typename... Args&gt;
internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt; AnyOf(
    const Args&amp;... matchers) {
  return internal::AnyOfMatcher&lt;typename std::decay&lt;const Args&amp;&gt;::type...&gt;(
      matchers...);
}

// AnyOfArray(array)
// AnyOfArray(pointer, count)
// AnyOfArray(container)
// AnyOfArray({ e1, e2, ..., en })
// AnyOfArray(iterator_first, iterator_last)
//
// AnyOfArray() verifies whether a given value matches any member of a
// collection of matchers.
//
// AllOfArray(array)
// AllOfArray(pointer, count)
// AllOfArray(container)
// AllOfArray({ e1, e2, ..., en })
// AllOfArray(iterator_first, iterator_last)
//
// AllOfArray() verifies whether a given value matches all members of a
// collection of matchers.
//
// The matchers can be specified as an array, a pointer and count, a container,
// an initializer list, or an STL iterator range. In each of these cases, the
// underlying matchers can be either values or matchers.

template &lt;typename Iter&gt;
inline internal::AnyOfArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
AnyOfArray(Iter first, Iter last) {
  return internal::AnyOfArrayMatcher&lt;
      typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;(first, last);
}

template &lt;typename Iter&gt;
inline internal::AllOfArrayMatcher&lt;
    typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;
AllOfArray(Iter first, Iter last) {
  return internal::AllOfArrayMatcher&lt;
      typename ::std::iterator_traits&lt;Iter&gt;::value_type&gt;(first, last);
}

template &lt;typename T&gt;
inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(const T* ptr, size_t count) {
  return AnyOfArray(ptr, ptr + count);
}

template &lt;typename T&gt;
inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(const T* ptr, size_t count) {
  return AllOfArray(ptr, ptr + count);
}

template &lt;typename T, size_t N&gt;
inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(const T (&amp;array)[N]) {
  return AnyOfArray(array, N);
}

template &lt;typename T, size_t N&gt;
inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(const T (&amp;array)[N]) {
  return AllOfArray(array, N);
}

template &lt;typename Container&gt;
inline internal::AnyOfArrayMatcher&lt;typename Container::value_type&gt; AnyOfArray(
    const Container&amp; container) {
  return AnyOfArray(container.begin(), container.end());
}

template &lt;typename Container&gt;
inline internal::AllOfArrayMatcher&lt;typename Container::value_type&gt; AllOfArray(
    const Container&amp; container) {
  return AllOfArray(container.begin(), container.end());
}

template &lt;typename T&gt;
inline internal::AnyOfArrayMatcher&lt;T&gt; AnyOfArray(
    ::std::initializer_list&lt;T&gt; xs) {
  return AnyOfArray(xs.begin(), xs.end());
}

template &lt;typename T&gt;
inline internal::AllOfArrayMatcher&lt;T&gt; AllOfArray(
    ::std::initializer_list&lt;T&gt; xs) {
  return AllOfArray(xs.begin(), xs.end());
}

// Args&lt;N1, N2, ..., Nk&gt;(a_matcher) matches a tuple if the selected
// fields of it matches a_matcher.  C++ doesn't support default
// arguments for function templates, so we have to overload it.
template &lt;size_t... k, typename InnerMatcher&gt;
internal::ArgsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type, k...&gt; Args(
    InnerMatcher&amp;&amp; matcher) {
  return internal::ArgsMatcher&lt;typename std::decay&lt;InnerMatcher&gt;::type, k...&gt;(
      std::forward&lt;InnerMatcher&gt;(matcher));
}

// AllArgs(m) is a synonym of m.  This is useful in
//
//   EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));
//
// which is easier to read than
//
//   EXPECT_CALL(foo, Bar(_, _)).With(Eq());
template &lt;typename InnerMatcher&gt;
inline InnerMatcher AllArgs(const InnerMatcher&amp; matcher) { return matcher; }

// Returns a matcher that matches the value of an optional&lt;&gt; type variable.
// The matcher implementation only uses '!arg' and requires that the optional&lt;&gt;
// type has a 'value_type' member type and that '*arg' is of type 'value_type'
// and is printable using 'PrintToString'. It is compatible with
// std::optional/std::experimental::optional.
// Note that to compare an optional type variable against nullopt you should
// use Eq(nullopt) and not Eq(Optional(nullopt)). The latter implies that the
// optional value contains an optional itself.
template &lt;typename ValueMatcher&gt;
inline internal::OptionalMatcher&lt;ValueMatcher&gt; Optional(
    const ValueMatcher&amp; value_matcher) {
  return internal::OptionalMatcher&lt;ValueMatcher&gt;(value_matcher);
}

// Returns a matcher that matches the value of a absl::any type variable.
template &lt;typename T&gt;
PolymorphicMatcher&lt;internal::any_cast_matcher::AnyCastMatcher&lt;T&gt; &gt; AnyWith(
    const Matcher&lt;const T&amp;&gt;&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::any_cast_matcher::AnyCastMatcher&lt;T&gt;(matcher));
}

// Returns a matcher that matches the value of a variant&lt;&gt; type variable.
// The matcher implementation uses ADL to find the holds_alternative and get
// functions.
// It is compatible with std::variant.
template &lt;typename T&gt;
PolymorphicMatcher&lt;internal::variant_matcher::VariantMatcher&lt;T&gt; &gt; VariantWith(
    const Matcher&lt;const T&amp;&gt;&amp; matcher) {
  return MakePolymorphicMatcher(
      internal::variant_matcher::VariantMatcher&lt;T&gt;(matcher));
}

#if GTEST_HAS_EXCEPTIONS

// Anything inside the `internal` namespace is internal to the implementation
// and must not be used in user code!
namespace internal {

class WithWhatMatcherImpl {
 public:
  WithWhatMatcherImpl(Matcher&lt;std::string&gt; matcher)
      : matcher_(std::move(matcher)) {}

  void DescribeTo(std::ostream* os) const {
    *os &lt;&lt; "contains .what() that ";
    matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os &lt;&lt; "contains .what() that does not ";
    matcher_.DescribeTo(os);
  }

  template &lt;typename Err&gt;
  bool MatchAndExplain(const Err&amp; err, MatchResultListener* listener) const {
    *listener &lt;&lt; "which contains .what() that ";
    return matcher_.MatchAndExplain(err.what(), listener);
  }

 private:
  const Matcher&lt;std::string&gt; matcher_;
};

inline PolymorphicMatcher&lt;WithWhatMatcherImpl&gt; WithWhat(
    Matcher&lt;std::string&gt; m) {
  return MakePolymorphicMatcher(WithWhatMatcherImpl(std::move(m)));
}

template &lt;typename Err&gt;
class ExceptionMatcherImpl {
  class NeverThrown {
   public:
    const char* what() const noexcept {
      return "this exception should never be thrown";
    }
  };

  // If the matchee raises an exception of a wrong type, we'd like to
  // catch it and print its message and type. To do that, we add an additional
  // catch clause:
  //
  //     try { ... }
  //     catch (const Err&amp;) { /* an expected exception */ }
  //     catch (const std::exception&amp;) { /* exception of a wrong type */ }
  //
  // However, if the `Err` itself is `std::exception`, we'd end up with two
  // identical `catch` clauses:
  //
  //     try { ... }
  //     catch (const std::exception&amp;) { /* an expected exception */ }
  //     catch (const std::exception&amp;) { /* exception of a wrong type */ }
  //
  // This can cause a warning or an error in some compilers. To resolve
  // the issue, we use a fake error type whenever `Err` is `std::exception`:
  //
  //     try { ... }
  //     catch (const std::exception&amp;) { /* an expected exception */ }
  //     catch (const NeverThrown&amp;) { /* exception of a wrong type */ }
  using DefaultExceptionType = typename std::conditional&lt;
      std::is_same&lt;typename std::remove_cv&lt;
                       typename std::remove_reference&lt;Err&gt;::type&gt;::type,
                   std::exception&gt;::value,
      const NeverThrown&amp;, const std::exception&amp;&gt;::type;

 public:
  ExceptionMatcherImpl(Matcher&lt;const Err&amp;&gt; matcher)
      : matcher_(std::move(matcher)) {}

  void DescribeTo(std::ostream* os) const {
    *os &lt;&lt; "throws an exception which is a " &lt;&lt; GetTypeName&lt;Err&gt;();
    *os &lt;&lt; " which ";
    matcher_.DescribeTo(os);
  }

  void DescribeNegationTo(std::ostream* os) const {
    *os &lt;&lt; "throws an exception which is not a " &lt;&lt; GetTypeName&lt;Err&gt;();
    *os &lt;&lt; " which ";
    matcher_.DescribeNegationTo(os);
  }

  template &lt;typename T&gt;
  bool MatchAndExplain(T&amp;&amp; x, MatchResultListener* listener) const {
    try {
      (void)(std::forward&lt;T&gt;(x)());
    } catch (const Err&amp; err) {
      *listener &lt;&lt; "throws an exception which is a " &lt;&lt; GetTypeName&lt;Err&gt;();
      *listener &lt;&lt; " ";
      return matcher_.MatchAndExplain(err, listener);
    } catch (DefaultExceptionType err) {
#if GTEST_HAS_RTTI
      *listener &lt;&lt; "throws an exception of type " &lt;&lt; GetTypeName(typeid(err));
      *listener &lt;&lt; " ";
#else
      *listener &lt;&lt; "throws an std::exception-derived type ";
#endif
      *listener &lt;&lt; "with description \"" &lt;&lt; err.what() &lt;&lt; "\"";
      return false;
    } catch (...) {
      *listener &lt;&lt; "throws an exception of an unknown type";
      return false;
    }

    *listener &lt;&lt; "does not throw any exception";
    return false;
  }

 private:
  const Matcher&lt;const Err&amp;&gt; matcher_;
};

}  // namespace internal

// Throws()
// Throws(exceptionMatcher)
// ThrowsMessage(messageMatcher)
//
// This matcher accepts a callable and verifies that when invoked, it throws
// an exception with the given type and properties.
//
// Examples:
//
//   EXPECT_THAT(
//       []() { throw std::runtime_error("message"); },
//       Throws&lt;std::runtime_error&gt;());
//
//   EXPECT_THAT(
//       []() { throw std::runtime_error("message"); },
//       ThrowsMessage&lt;std::runtime_error&gt;(HasSubstr("message")));
//
//   EXPECT_THAT(
//       []() { throw std::runtime_error("message"); },
//       Throws&lt;std::runtime_error&gt;(
//           Property(&amp;std::runtime_error::what, HasSubstr("message"))));

template &lt;typename Err&gt;
PolymorphicMatcher&lt;internal::ExceptionMatcherImpl&lt;Err&gt;&gt; Throws() {
  return MakePolymorphicMatcher(
      internal::ExceptionMatcherImpl&lt;Err&gt;(A&lt;const Err&amp;&gt;()));
}

template &lt;typename Err, typename ExceptionMatcher&gt;
PolymorphicMatcher&lt;internal::ExceptionMatcherImpl&lt;Err&gt;&gt; Throws(
    const ExceptionMatcher&amp; exception_matcher) {
  // Using matcher cast allows users to pass a matcher of a more broad type.
  // For example user may want to pass Matcher&lt;std::exception&gt;
  // to Throws&lt;std::runtime_error&gt;, or Matcher&lt;int64&gt; to Throws&lt;int32&gt;.
  return MakePolymorphicMatcher(internal::ExceptionMatcherImpl&lt;Err&gt;(
      SafeMatcherCast&lt;const Err&amp;&gt;(exception_matcher)));
}

template &lt;typename Err, typename MessageMatcher&gt;
PolymorphicMatcher&lt;internal::ExceptionMatcherImpl&lt;Err&gt;&gt; ThrowsMessage(
    MessageMatcher&amp;&amp; message_matcher) {
  static_assert(std::is_base_of&lt;std::exception, Err&gt;::value,
                "expected an std::exception-derived type");
  return Throws&lt;Err&gt;(internal::WithWhat(
      MatcherCast&lt;std::string&gt;(std::forward&lt;MessageMatcher&gt;(message_matcher))));
}

#endif  // GTEST_HAS_EXCEPTIONS

// These macros allow using matchers to check values in Google Test
// tests.  ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)
// succeed if and only if the value matches the matcher.  If the assertion
// fails, the value and the description of the matcher will be printed.
#define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\
    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)
#define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\
    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)

// MATCHER* macroses itself are listed below.
#define MATCHER(name, description)                                             \
  class name##Matcher                                                          \
      : public ::testing::internal::MatcherBaseImpl&lt;name##Matcher&gt; {           \
   public:                                                                     \
    template &lt;typename arg_type&gt;                                               \
    class gmock_Impl : public ::testing::MatcherInterface&lt;const arg_type&amp;&gt; {   \
     public:                                                                   \
      gmock_Impl() {}                                                          \
      bool MatchAndExplain(                                                    \
          const arg_type&amp; arg,                                                 \
          ::testing::MatchResultListener* result_listener) const override;     \
      void DescribeTo(::std::ostream* gmock_os) const override {               \
        *gmock_os &lt;&lt; FormatDescription(false);                                 \
      }                                                                        \
      void DescribeNegationTo(::std::ostream* gmock_os) const override {       \
        *gmock_os &lt;&lt; FormatDescription(true);                                  \
      }                                                                        \
                                                                               \
     private:                                                                  \
      ::std::string FormatDescription(bool negation) const {                   \
        ::std::string gmock_description = (description);                       \
        if (!gmock_description.empty()) {                                      \
          return gmock_description;                                            \
        }                                                                      \
        return ::testing::internal::FormatMatcherDescription(negation, #name,  \
                                                             {});              \
      }                                                                        \
    };                                                                         \
  };                                                                           \
  GTEST_ATTRIBUTE_UNUSED_ inline name##Matcher name() { return {}; }           \
  template &lt;typename arg_type&gt;                                                 \
  bool name##Matcher::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(                   \
      const arg_type&amp; arg,                                                     \
      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_) \
      const

#define MATCHER_P(name, p0, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP, description, (p0))
#define MATCHER_P2(name, p0, p1, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP2, description, (p0, p1))
#define MATCHER_P3(name, p0, p1, p2, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP3, description, (p0, p1, p2))
#define MATCHER_P4(name, p0, p1, p2, p3, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP4, description, (p0, p1, p2, p3))
#define MATCHER_P5(name, p0, p1, p2, p3, p4, description)    \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP5, description, \
                         (p0, p1, p2, p3, p4))
#define MATCHER_P6(name, p0, p1, p2, p3, p4, p5, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP6, description,  \
                         (p0, p1, p2, p3, p4, p5))
#define MATCHER_P7(name, p0, p1, p2, p3, p4, p5, p6, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP7, description,      \
                         (p0, p1, p2, p3, p4, p5, p6))
#define MATCHER_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP8, description,          \
                         (p0, p1, p2, p3, p4, p5, p6, p7))
#define MATCHER_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP9, description,              \
                         (p0, p1, p2, p3, p4, p5, p6, p7, p8))
#define MATCHER_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description) \
  GMOCK_INTERNAL_MATCHER(name, name##MatcherP10, description,                  \
                         (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))

#define GMOCK_INTERNAL_MATCHER(name, full_name, description, args)             \
  template &lt;GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAMS(args)&gt;                      \
  class full_name : public ::testing::internal::MatcherBaseImpl&lt;               \
                        full_name&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt;&gt; { \
   public:                                                                     \
    using full_name::MatcherBaseImpl::MatcherBaseImpl;                         \
    template &lt;typename arg_type&gt;                                               \
    class gmock_Impl : public ::testing::MatcherInterface&lt;const arg_type&amp;&gt; {   \
     public:                                                                   \
      explicit gmock_Impl(GMOCK_INTERNAL_MATCHER_FUNCTION_ARGS(args))          \
          : GMOCK_INTERNAL_MATCHER_FORWARD_ARGS(args) {}                       \
      bool MatchAndExplain(                                                    \
          const arg_type&amp; arg,                                                 \
          ::testing::MatchResultListener* result_listener) const override;     \
      void DescribeTo(::std::ostream* gmock_os) const override {               \
        *gmock_os &lt;&lt; FormatDescription(false);                                 \
      }                                                                        \
      void DescribeNegationTo(::std::ostream* gmock_os) const override {       \
        *gmock_os &lt;&lt; FormatDescription(true);                                  \
      }                                                                        \
      GMOCK_INTERNAL_MATCHER_MEMBERS(args)                                     \
                                                                               \
     private:                                                                  \
      ::std::string FormatDescription(bool negation) const {                   \
        ::std::string gmock_description = (description);                       \
        if (!gmock_description.empty()) {                                      \
          return gmock_description;                                            \
        }                                                                      \
        return ::testing::internal::FormatMatcherDescription(                  \
            negation, #name,                                                   \
            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(      \
                ::std::tuple&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt;(        \
                    GMOCK_INTERNAL_MATCHER_MEMBERS_USAGE(args))));             \
      }                                                                        \
    };                                                                         \
  };                                                                           \
  template &lt;GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAMS(args)&gt;                      \
  inline full_name&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt; name(             \
      GMOCK_INTERNAL_MATCHER_FUNCTION_ARGS(args)) {                            \
    return full_name&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt;(                \
        GMOCK_INTERNAL_MATCHER_ARGS_USAGE(args));                              \
  }                                                                            \
  template &lt;GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAMS(args)&gt;                      \
  template &lt;typename arg_type&gt;                                                 \
  bool full_name&lt;GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args)&gt;::gmock_Impl&lt;        \
      arg_type&gt;::MatchAndExplain(const arg_type&amp; arg,                          \
                                 ::testing::MatchResultListener*               \
                                     result_listener GTEST_ATTRIBUTE_UNUSED_)  \
      const

#define GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAMS(args) \
  GMOCK_PP_TAIL(                                     \
      GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAM, , args))
#define GMOCK_INTERNAL_MATCHER_TEMPLATE_PARAM(i_unused, data_unused, arg) \
  , typename arg##_type

#define GMOCK_INTERNAL_MATCHER_TYPE_PARAMS(args) \
  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_TYPE_PARAM, , args))
#define GMOCK_INTERNAL_MATCHER_TYPE_PARAM(i_unused, data_unused, arg) \
  , arg##_type

#define GMOCK_INTERNAL_MATCHER_FUNCTION_ARGS(args) \
  GMOCK_PP_TAIL(dummy_first GMOCK_PP_FOR_EACH(     \
      GMOCK_INTERNAL_MATCHER_FUNCTION_ARG, , args))
#define GMOCK_INTERNAL_MATCHER_FUNCTION_ARG(i, data_unused, arg) \
  , arg##_type gmock_p##i

#define GMOCK_INTERNAL_MATCHER_FORWARD_ARGS(args) \
  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_FORWARD_ARG, , args))
#define GMOCK_INTERNAL_MATCHER_FORWARD_ARG(i, data_unused, arg) \
  , arg(::std::forward&lt;arg##_type&gt;(gmock_p##i))

#define GMOCK_INTERNAL_MATCHER_MEMBERS(args) \
  GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_MEMBER, , args)
#define GMOCK_INTERNAL_MATCHER_MEMBER(i_unused, data_unused, arg) \
  const arg##_type arg;

#define GMOCK_INTERNAL_MATCHER_MEMBERS_USAGE(args) \
  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_MEMBER_USAGE, , args))
#define GMOCK_INTERNAL_MATCHER_MEMBER_USAGE(i_unused, data_unused, arg) , arg

#define GMOCK_INTERNAL_MATCHER_ARGS_USAGE(args) \
  GMOCK_PP_TAIL(GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_MATCHER_ARG_USAGE, , args))
#define GMOCK_INTERNAL_MATCHER_ARG_USAGE(i, data_unused, arg_unused) \
  , gmock_p##i

// To prevent ADL on certain functions we put them on a separate namespace.
using namespace no_adl;  // NOLINT

}  // namespace testing

GTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251 5046

// Include any custom callback matchers added by the local installation.
// We must include this header at the end to make sure it can use the
// declarations from this file.
#include "gmock/internal/custom/gmock-matchers.h"

#endif  // GOOGLEMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>